<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[启用和安装 EPEL & WEBTATIC 源]]></title>
    <url>%2F2018%2F06%2F12%2Fepel-and-webtatic-for-linux%2F</url>
    <content type="text"><![CDATA[1 EPEL 特点 2 EPEL 启用 3 查询 EPEL 包含内容 4 安装 WEBTATIC 源 EPEL(Extra Packages for Enterprise Linux, 企业版 Linux 附加软件包) 是一个 Fedora 特别兴趣小组，用以创建、维护以及管理针对企业版 Linux 的一个高质量附加软件包集，面向的对象包括但不限于红帽企业版 Linux (RHEL)、 CentOS、Scientific Linux (SL)、Oracle Linux (OL) 。 Webtatic Yum repository，是一个 CentOS/RHEL 软件存储库，其中包含较新的与 WEB 相关的软件包。 1 EPEL 特点 EPEL 的软件包通常不会与企业版 Linux 官方源中的软件包发生冲突，或者互相替换文件。EPEL 项目与 Fedora 基本一致，包含完整的构建系统、升级管理器、镜像管理器等等。另外，其在使用过程中，有以下特点： 不用去换原来 yum 源，安装后会产生新的 repo； EPEL 会有很多源地址，如果一个下载不成功，会去另外的地址下载； 更新时，如果下载的包不全，就不会进行安装，保证了依赖完整性。 2 EPEL 启用 1234# 查找软件名称yum search epel# 安装yum install epel-release 注：yum 搜索的结果中 epel-release.noarch 就是我们需要的软件包。安装可以不用包含软件包名称中 . 之后的部分，当然包含也没有问题。. 后的部分表示软件包适应系统构架。noarch 表示通用型；x86_64 表示 64 位系统；i686 表示 32 位系统。 3 查询 EPEL 包含内容 在 CentOS rpm 包 中介绍过 rpm 包相关内容及命令，这里可以使用 rpm 查询命令查看 EPEL 包含的内容。 1rpm -ql epel-release 4 安装 WEBTATIC 源 对于服务器而言，最为常见的即是提供 web 服务，而对于 web 服务中常用的一些软件，在系统默认的源下，一般版本较低，如若需要使用相对较新的版本（如 PHP），WEBTATIC 源是一个很好的选择。 1234567# CentOS/RHEL 7.x:yum install epel-releaserpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm# CentOS/RHEL 6.x:yum install epel-releaserpm -Uvh https://mirror.webtatic.com/yum/el6/latest.rpm]]></content>
      <categories>
        <category>系统环境</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>EPEL</tag>
        <tag>WEBTATIC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos rpm 包]]></title>
    <url>%2F2018%2F06%2F12%2Fcentos-rpm%2F</url>
    <content type="text"><![CDATA[1 RPM 包与源码包的区别 2 RPM 包命名 &amp; 依赖性 3 RPM 包的安装、升级、卸载和查询 RPM 包，在 CentOS 使用过程中，也是经常会遇到的一种软件包形式，对于该类型包的相关操作进行了解，有助于日常的使用。 1 RPM 包与源码包的区别 软件包分类 源码包：C 源代码包 rpm 包：编译之后的二进制包 源码包 优点：开源，并可以自由选择所需功能，可看源代码，卸载方便（直接删除安装位置）; 缺点：安装步骤繁琐，编译时间过长。 RPM 包 优点：使用简单，只需要几个命令就可以实现包的安装、升级、查询、卸载，安装速度快； 缺点：不能看源代码，功能选择不如源代码灵活，依赖性。 2 RPM 包命名 &amp; 依赖性 命名规则 12# 举例包名httpd-2.4.6-67.el7.centos.x86_64.rpm 命名分段 说明 httpd 软件包名 2.4.6 软件版本 67 发行次数 el7.centos 适合的 linux 平台 x86_64 适合的硬件平台 rpm 扩展名 依赖性 树形依赖：a-&gt;b-&gt;c，即 a 依赖 b ， b 依赖 c 。 环形依赖：a-&gt;b-&gt;c-&gt;a 模块依赖：模块依赖查询网站，www.rpmfind.net 3 RPM 包的安装、升级、卸载和查询 包全名 ＆ 包名对比说明 包全名 包名 例如：httpd-2.4.6-67.el7.centos.x86_64.rpm 例如：httpd 操作包时为没有安装的软件包时，使用 包全名。 操作包时为已经安装的软件包时，使用 包名。 安装、升级时使用 查询、卸载时使用 安装 123456789rpm -ivh [包全名]# 选项：# -i(install) 安装# -v(verbose) 显示详细信息# -h(hash) 显示进度# --nodeps 不检测依赖性# 如rpm -ivh httpd-2.4.6-67.el7.centos.x86_64.rpm 注：可能会有很多依赖性问题出现，根据一个个依赖性继续 rpm 安装即可。 升级 123rpm -Uvh [包全名]# 选项：# -U(upgrade) 升级 卸载 123456789101112rpm -e [包名]# 选项：# -e(erase) 卸载# --nodeps 不检测依赖性# 如rpm -e httpd# 报错信息# 错误：依赖检测失败：# httpd = 2.4.6-67.el7.centos 被 (已安裝) httpd-devel-2.4.6-67.el7.centos.x86_64 需要rpm -e httpd-develrpm -e httpd 注：卸载要按照安装依赖性的反方向卸载。 查询 12345678910111213141516171819202122232425# 查询是否安装rpm -q [包名]# 选项：# -q(query) 查询# -a(all) 所有# 查询软件包的详细信息rpm -qi [包名]# 选项：# -i(information) 查询软件包信息# 查询包中文件安装位置rpm -ql [包名]# 选项：# -l(list) 列表# 查询系统文件属于哪个 rpm 包rpm -qf [系统文件名]# 选项：# -f(file) 查询系统文件属于哪个 rpm 包# 查询软件包的依赖性rpm -qR [包名]# 选项：# -R(requires) 查询软件包的依赖性]]></content>
      <categories>
        <category>系统环境</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 源 & yum 管理命令]]></title>
    <url>%2F2018%2F06%2F11%2Fcentos-yum-repo-admin%2F</url>
    <content type="text"><![CDATA[1 yum 源 2 网络源 3 光盘源 4 yum 命令 1 yum 源 源，是 linux 系统中，用于管理相关软件来源的一个配置，而 yum 源，则是 red 系列的一个管理特例。 源的目录位置：/etc/yum.repo.d/ 如上图中，如果系统能与外网相通，则使用默认的网络 yum 源文件 CentOS-Base.repo；若只能内网通信，则使用光盘 yum 源文件 CentOS-Media.repo。 源文件配置说明： 参数 说明 [base] 容器名称，一定要放在 [] 中 mirrorlist 镜像站点，用这个地址或下面那个地址都行 baseurl yum 源服务器地址。默认是 CentOS 官方的 yum 源服务器，是可以使用的，如若访问速度很慢，可以改为合适的地址。 enabled 此容器是否生效，如果不配置，或配置为 enabled=1 表示生效；配置为 enabled=0 表示不生效。 gpgcheck 配置 RPM 数字证书是否生效， gpgcheck=1：代表生效； gpgcheck=0：代表不生效。 gpgkey 数字证书的公钥文件保存位置，一般不用修改。 2 网络源 12# 查看网络源配置vim /etc/yum.repos.d/CentOS-Base.repo 3 光盘源 当处于离线状态时，我们需要从其他源来安装软件，如：光盘。 相关的步骤如下： 挂载光盘 12345# 新建光盘挂载点mkdir /mnt/cdrom# 把设备文件名挂载到挂载点mount /dev/cdrom /mnt/cdrom 让网络 yum 源失效 12345# 进入 yum 源配置文件夹cd /etc/yum.repos.d/# 将 yum 网络源备份mv CentOS-Base.repo CentOS-Base.repo.bak 注：网络 yum 源失效后，系统默认使用光盘 yum 源。 修改光盘 yum 源 1vim CentOS-Media.repo 12345678910[c7-media]name=CentOS-$releasever - Mediabaseurl=file:///mnt/cdrom# file:///media/cdrom/# file:///media/cdrecorder/# 注释这两个不存在的地址gpgcheck=1enabled=1# 把 enabled=0 改为1，让这个yum源配置文件生效gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 4 yum 命令 在 linux 日常使用过程中， yum 操作经常会涉及到，以下对常用的方式进行总结： 查询 12345# 在远程服务器上查询所有可用的软件包列表yum list# 搜索远程服务器上所有和关键字相关的包yum search [keywords] 安装 1234yum -y install [package-name]# 选项：# install 安装# -y 自动回复 yes 升级 1234yum -y update [package-name]# 选项：# update 升级# -y 自动回复 yes 卸载 1234yum -y remove [package-name]# 选项：# remove 卸载# -y 自动回复 yes]]></content>
      <categories>
        <category>系统环境</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>yum</tag>
        <tag>源管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 和 vmware 共存工作]]></title>
    <url>%2F2018%2F06%2F09%2Fdocker-work-with-vmware%2F</url>
    <content type="text"><![CDATA[1 起因 2 解决方案 3 更好的办法 4 bcdedit 简单用法 1 起因 在之前装好系统环境后，想要在工作平台上模拟服务器的环境，来进行一下相关的实验，因此，系统上装好有 vmware 软件，该软件下的快照功能，让我对于相关的实验环境有一个很好的备份操作，很是 nice。 而另一个方面，当前 docker 的活跃程度，也让我这个技术屌丝，内心有点点萌动，想了解一下，如果可以玩出点花样，那也是极好的。 但是，当我尝试了在 windows 环境下，安装好了 docker 后，提示要开启 Hyper-V ，开启后，正常启动 docker 服务。（控制面板-&gt;程序-&gt;程序和功能-&gt;启用或关闭 Windows 功能） 某天的某天，再次捡起 vmware 时，确报出了错误。 后面查阅了相关资料，原来，Hyper-V 与 vmware 有冲突，只能二选一。 2 解决方案 当需要使用 vmware 时，我们按开启的方式，再次关闭 Hyper-V ，这样，软件就能正常的打开了。 但这样操作，有一个不好的地方，每开启或关闭一次，系统都必需要重启一次，这导致每次系统都进行了一次程序的安装和卸载，费时不高效。 3 更好的办法 建立两个启动项，一个开启了 Hyper-V，而另一个则关闭，这样，我们可以在需要该功能时，在系统启动界面自由的选择相应的启动项，而不用频繁的安装和卸载 Hyper-V。 建立新的启动项，并将 Hyper-V 功能关闭，命令如下： 1234# win + X 开启命令行，注意：必须以管理员身份执行bcdedit /copy &#123;default&#125; /d "Windows 10 Without Hyper-V"# 以上命令得到输出 &#123;xxxxxxxxxxxxxxxxxxx&#125;bcdedit /set &#123;xxxxxxxxxxxxxxxxxxx&#125; hypervisorlaunchtype off 如图： 我们可以通过命令：bcdedit /enum，查看启动项列表。 4 bcdedit 简单用法 以上的操作中，用到了一个很重要的命令：bcdedit，其主要功能是建立和重新配置 bootloader。（Boot Configuration Data Edit） 有一些常用的用法： 1234567891011121314151617181920212223242526272829303132# 查看帮助bcdedit /?# 查看启动项列表bcdedit /enum# or 查看所有bcdedit /enum all# 设置某个启动项配置值bcdedit /set &#123;xxxx&#125; description "Windows 10 With Hyper-V"# orbcdedit /set &#123;xxxx&#125; hypervisorlaunchtype on# 设置启动项显示排列顺序bcdedit /displayorder &#123;current&#125; &#123;xxxxx&#125; &#123;xxxxxx&#125;# 创建新的启动项bcdedit /create /d "A New One"# 复制启动项bcdedit /copy &#123;xxxx&#125; /d "A Copy One"# 删除启动项bcdedit /delete &#123;xxxx&#125;# or 彻底删除bcdedit /delete /cleanup &#123;xxxx&#125;# 设置默认启动项bcdedit /default &#123;xxxxx&#125;# 设置默认的启动菜单显示时间，单位秒bcdedit /timeout 10]]></content>
      <categories>
        <category>系统环境</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>vmware</tag>
        <tag>Hyper-V</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitlab 配置腾讯企业邮箱邮件发送功能]]></title>
    <url>%2F2018%2F03%2F23%2Fgitlab-config-for-email%2F</url>
    <content type="text"><![CDATA[1 背景 2 gitlab 配置 3 执行效果 在 gitlab 安装完成后，在实际的应用操作过程中，很多相关的功能依赖邮件服务，因此，将 gitlab 的邮件发送服务配置好，应用该工具很重要的一个部分。 在国内市场上，目前好用的邮箱产品有好几款，而这里所要使用的是 腾讯企业邮箱 ，我们只需要有一个独立掌控的域名就非常容易开通一个。 1 背景 举例域名：demo.com 举例账号：server@demo.com 账号密码：123456 邮件发送显示名：Server 注意 在企业邮箱账号添加后，你需要登录一次邮箱，系统会让你再次修改一次密码，而这会影响之后的配置中的参数值。 登录到邮箱后，进入设置面板，需要将 SMTP 功能打开，以及相关的通讯端口也会有显示，如下图： 2 gitlab 配置 配置文件路径：/etc/gitlab/gitlab.rb &#123;.line-numbers&#125;12345678910111213141516171819# gitlab 发信人user['git_user_name'] = "Server"user['git_user_email'] = "server@demo.com"gitlab_rails['gitlab_email_from'] = 'server@demo.com'gitlab_rails['gitlab_email_display_name'] = 'Server'# 通过 SMTP 方式发送邮件gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = "smtp.exmail.qq.com"gitlab_rails['smtp_port'] = 465# 邮箱账号&amp;密码gitlab_rails['smtp_user_name'] = "server@demo.com"gitlab_rails['smtp_password'] = "123456"gitlab_rails['smtp_domain'] = "exmail.qq.com"gitlab_rails['smtp_authentication'] = "login"gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = true 配置完成后，执行以下命令： 1234# 刷新 gitlab 配置gitlab-ctl reconfigure# 重启服务gitlab-ctl restart 3 执行效果 当在 gitlab 平台操作 SSH Key 时，系统会发出如下邮件提醒：]]></content>
      <categories>
        <category>工具</category>
        <category>gitlab</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>git</tag>
        <tag>gitlab</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html 开发规范指导手册]]></title>
    <url>%2F2018%2F03%2F20%2Fhtml-style-guide%2F</url>
    <content type="text"><![CDATA[1 背景 2 代码风格 2.1 缩进与换行 2.2 命名 2.3 标签 2.4 属性 3 通用 3.1 DOCTYPE 3.2 编码 3.3 CSS 和 JavaScript 引入 4 head 4.1 title 4.2 favicon 4.3 viewport 5 图片 6 表单 6.1 控件标题 6.2 按钮 6.3 可访问性 (A11Y) 7 多媒体 8 模板中的 HTML 1 背景 转自。 HTML 作为描述网页结构的超文本标记语言，在 B/S 架构程序一直有着广泛的应用。本文档的目标是使 HTML 代码风格保持一致，容易被理解和被维护。 2 代码风格 2.1 缩进与换行 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 解释： 对于非 HTML 标签之间的缩进，比如 script 或 style 标签内容缩进，与 script 或 style 标签的缩进同级。 示例： 12345678910111213141516&lt;style&gt;/* 样式内容的第一级缩进与所属的 style 标签对齐 */ul &#123; padding: 0;&#125;&lt;/style&gt;&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// 脚本代码的第一级缩进与所属的 script 标签对齐require(['app'], function (app) &#123; app.init();&#125;);&lt;/script&gt; [建议] 每行不得超过 120 个字符。 解释： 过长的代码不容易阅读与维护。但是考虑到 HTML 的特殊性，不做硬性要求。 2.2 命名 [强制] class 必须单词全字母小写，单词间以 - 分隔。 [强制] class 必须代表相应模块或部件的内容或功能，不得以样式信息进行命名。 示例： 12345&lt;!-- good --&gt;&lt;div class="sidebar"&gt;&lt;/div&gt;&lt;!-- bad --&gt;&lt;div class="left"&gt;&lt;/div&gt; [强制] 元素 id 必须保证页面唯一。 解释： 同一个页面中，不同的元素包含相同的 id，不符合 id 的属性含义。并且使用 document.getElementById 时可能导致难以追查的问题。 [建议] id 建议单词全字母小写，单词间以 - 分隔。同项目必须保持风格一致。 [建议] id、class 命名，在避免冲突并描述清楚的前提下尽可能短。 示例： 1234567891011121314&lt;!-- good --&gt;&lt;div id="nav"&gt;&lt;/div&gt;&lt;!-- bad --&gt;&lt;div id="navigation"&gt;&lt;/div&gt;&lt;!-- good --&gt;&lt;p class="comment"&gt;&lt;/p&gt;&lt;!-- bad --&gt;&lt;p class="com"&gt;&lt;/p&gt;&lt;!-- good --&gt;&lt;span class="author"&gt;&lt;/span&gt;&lt;!-- bad --&gt;&lt;span class="red"&gt;&lt;/span&gt; [强制] 禁止为了 hook 脚本，创建无样式信息的 class。 解释： 不允许 class 只用于让 JavaScript 选择某些元素，class 应该具有明确的语义和样式。否则容易导致 CSS class 泛滥。 使用 id、属性选择作为 hook 是更好的方式。 [强制] 同一页面，应避免使用相同的 name 与 id。 解释： IE 浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心。 一个比较好的实践是，为 id 和 name 使用不同的命名法。 示例： 123456&lt;input name="foo"&gt;&lt;div id="foo"&gt;&lt;/div&gt;&lt;script&gt;// IE6 将显示 INPUTalert(document.getElementById('foo').tagName);&lt;/script&gt; 2.3 标签 [强制] 标签名必须使用小写字母。 示例： 12345&lt;!-- good --&gt;&lt;p&gt;Hello StyleGuide!&lt;/p&gt;&lt;!-- bad --&gt;&lt;P&gt;Hello StyleGuide!&lt;/P&gt; [强制] 对于无需自闭合的标签，不允许自闭合。 解释： 常见无需自闭合标签有 input、br、img、hr 等。 示例： 12345&lt;!-- good --&gt;&lt;input type="text" name="title"&gt;&lt;!-- bad --&gt;&lt;input type="text" name="title" /&gt; [强制] 对 HTML5 中规定允许省略的闭合标签，不允许省略闭合标签。 解释： 对代码体积要求非常严苛的场景，可以例外。比如：第三方页面使用的投放系统。 示例： 1234567891011&lt;!-- good --&gt;&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;&lt;!-- bad --&gt;&lt;ul&gt; &lt;li&gt;first &lt;li&gt;second&lt;/ul&gt; [强制] 标签使用必须符合标签嵌套规则。 解释： 比如 div 不得置于 p 中，tbody 必须置于 table 中。 详细的标签嵌套规则参见HTML DTD中的 Elements 定义部分。 [建议] HTML 标签的使用应该遵循标签的语义。 解释： 下面是常见标签语义 p - 段落 h1,h2,h3,h4,h5,h6 - 层级标题 strong,em - 强调 ins - 插入 del - 删除 abbr - 缩写 code - 代码标识 cite - 引述来源作品的标题 q - 引用 blockquote - 一段或长篇引用 ul - 无序列表 ol - 有序列表 dl,dt,dd - 定义列表 示例： 12345&lt;!-- good --&gt;&lt;p&gt;Esprima serves as an important &lt;strong&gt;building block&lt;/strong&gt; for some JavaScript language tools.&lt;/p&gt;&lt;!-- bad --&gt;&lt;div&gt;Esprima serves as an important &lt;span class="strong"&gt;building block&lt;/span&gt; for some JavaScript language tools.&lt;/div&gt; [建议] 在 CSS 可以实现相同需求的情况下不得使用表格进行布局。 解释： 在兼容性允许的情况下应尽量保持语义正确性。对网格对齐和拉伸性有严格要求的场景允许例外，如多列复杂表单。 [建议] 标签的使用应尽量简洁，减少不必要的标签。 示例： 1234567&lt;!-- good --&gt;&lt;img class="avatar" src="image.png"&gt;&lt;!-- bad --&gt;&lt;span class="avatar"&gt; &lt;img src="image.png"&gt;&lt;/span&gt; 2.4 属性 [强制] 属性名必须使用小写字母。 示例： 12345&lt;!-- good --&gt;&lt;table cellspacing="0"&gt;...&lt;/table&gt;&lt;!-- bad --&gt;&lt;table cellSpacing="0"&gt;...&lt;/table&gt; [强制] 属性值必须用双引号包围。 解释： 不允许使用单引号，不允许不使用引号。 示例： 123456&lt;!-- good --&gt;&lt;script src="esl.js"&gt;&lt;/script&gt;&lt;!-- bad --&gt;&lt;script src='esl.js'&gt;&lt;/script&gt;&lt;script src=esl.js&gt;&lt;/script&gt; [建议] 布尔类型的属性，建议不添加属性值。 示例： 12&lt;input type="text" disabled&gt;&lt;input type="checkbox" value="1" checked&gt; [建议] 自定义属性建议以 xxx- 为前缀，推荐使用 data-。 解释： 使用前缀有助于区分自定义属性和标准定义的属性。 示例： 1&lt;ol data-ui-type="Select"&gt;&lt;/ol&gt; 3 通用 3.1 DOCTYPE [强制] 使用 HTML5 的 doctype 来启用标准模式，建议使用大写的 DOCTYPE。 示例： 1&lt;!DOCTYPE html&gt; [建议] 启用 IE Edge 模式。 示例： 1&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt; [建议] 在 html 标签上设置正确的 lang 属性。 解释： 有助于提高页面的可访问性，如：让语音合成工具确定其所应该采用的发音，令翻译工具确定其翻译语言等。 示例： 1&lt;html lang="zh-CN"&gt; 3.2 编码 [强制] 页面必须使用精简形式，明确指定字符编码。指定字符编码的 meta 必须是 head 的第一个直接子元素。 解释： 见 HTML5 Charset能用吗 一文。 示例： 123456789&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; ...... &lt;/head&gt; &lt;body&gt; ...... &lt;/body&gt;&lt;/html&gt; [建议] HTML 文件使用无 BOM 的 UTF-8 编码。 解释： UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。 3.3 CSS 和 JavaScript 引入 [强制] 引入 CSS 时必须指明 rel=&quot;stylesheet&quot;。 示例： 1&lt;link rel="stylesheet" href="page.css"&gt; [建议] 引入 CSS 和 JavaScript 时无须指明 type 属性。 解释： text/css 和 text/javascript 是 type 的默认值。 [建议] 展现定义放置于外部 CSS 中，行为定义放置于外部 JavaScript 中。 解释： 结构-样式-行为的代码分离，对于提高代码的可阅读性和维护性都有好处。 [建议] 在 head 中引入页面需要的所有 CSS 资源。 解释： 在页面渲染的过程中，新的CSS可能导致元素的样式重新计算和绘制，页面闪烁。 [建议] JavaScript 应当放在页面末尾，或采用异步加载。 解释： 将 script 放在页面中间将阻断页面的渲染。出于性能方面的考虑，如非必要，请遵守此条建议。 示例： 1234&lt;body&gt; &lt;!-- a lot of elements --&gt; &lt;script src="init-behavior.js"&gt;&lt;/script&gt;&lt;/body&gt; [建议] 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。 解释： 使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境。 示例： 1&lt;script src="//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js"&gt;&lt;/script&gt; 4 head 4.1 title [强制] 页面必须包含 title 标签声明标题。 [强制] title 必须作为 head 的直接子元素，并紧随 charset 声明之后。 解释： title 中如果包含 ASCII 之外的字符，浏览器需要知道字符编码类型才能进行解码，否则可能导致乱码。 示例： 1234&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt; 4.2 favicon [强制] 保证 favicon 可访问。 解释： 在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 favicon.ico 。为了保证 favicon 可访问，避免 404，必须遵循以下两种方法之一： 在 Web Server 根目录放置 favicon.ico 文件。 使用 link 指定 favicon。 示例： 1&lt;link rel="shortcut icon" href="path/to/favicon.ico"&gt; 4.3 viewport [建议] 若页面欲对移动设备友好，需指定页面的 viewport。 解释： viewport meta tag 可以设置可视区域的宽度和初始缩放大小，避免在移动设备上出现页面展示不正常。 比如，在页面宽度小于 980px 时，若需 iOS 设备友好，应当设置 viewport 的 width 值来适应你的页面宽度。同时因为不同移动设备分辨率不同，在设置时，应当使用 device-width 和 device-height 变量。 另外，为了使 viewport 正常工作，在页面内容样式布局设计上也要做相应调整，如避免绝对定位等。关于 viewport 的更多介绍，可以参见 Safari Web Content Guide的介绍 5 图片 [强制] 禁止 img 的 src 取值为空。延迟加载的图片也要增加默认的 src。 解释： src 取值为空，会导致部分浏览器重新加载一次当前页面，参考：https://developer.yahoo.com/performance/rules.html#emptysrc [建议] 避免为 img 添加不必要的 title 属性。 解释： 多余的 title 影响看图体验，并且增加了页面尺寸。 [建议] 为重要图片添加 alt 属性。 解释： 可以提高图片加载失败时的用户体验。 [建议] 添加 width 和 height 属性，以避免页面抖动。 [建议] 有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现。 解释： 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 CSS 背景图实现。 6 表单 6.1 控件标题 [强制] 有文本标题的控件必须使用 label 标签将其与其标题相关联。 解释： 有两种方式： 将控件置于 label 内。 label 的 for 属性指向控件的 id。 推荐使用第一种，减少不必要的 id。如果 DOM 结构不允许直接嵌套，则应使用第二种。 示例： 123&lt;label&gt;&lt;input type="checkbox" name="confirm" value="on"&gt; 我已确认上述条款&lt;/label&gt;&lt;label for="username"&gt;用户名：&lt;/label&gt; &lt;input type="textbox" name="username" id="username"&gt; 6.2 按钮 [强制] 使用 button 元素时必须指明 type 属性值。 解释： button 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交。为显示区分其作用方便理解，必须给出 type 属性。 示例： 12&lt;button type="submit"&gt;提交&lt;/button&gt;&lt;button type="button"&gt;取消&lt;/button&gt; [建议] 尽量不要使用按钮类元素的 name 属性。 解释： 由于浏览器兼容性问题，使用按钮的 name 属性会带来许多难以发现的问题。具体情况可参考此文。 6.3 可访问性 (A11Y) [建议] 负责主要功能的按钮在 DOM 中的顺序应靠前。 解释： 负责主要功能的按钮应相对靠前，以提高可访问性。如果在 CSS 中指定了 float: right 则可能导致视觉上主按钮在前，而 DOM 中主按钮靠后的情况。 示例： 12345678910111213141516171819202122232425&lt;!-- good --&gt;&lt;style&gt;.buttons .button-group &#123; float: right;&#125;&lt;/style&gt;&lt;div class="buttons"&gt; &lt;div class="button-group"&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;button type="button"&gt;取消&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- bad --&gt;&lt;style&gt;.buttons button &#123; float: right;&#125;&lt;/style&gt;&lt;div class="buttons"&gt; &lt;button type="button"&gt;取消&lt;/button&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;/div&gt; [建议] 当使用 JavaScript 进行表单提交时，如果条件允许，应使原生提交功能正常工作。 解释： 当浏览器 JS 运行错误或关闭 JS 时，提交功能将无法工作。如果正确指定了 form 元素的 action 属性和表单控件的 name 属性时，提交仍可继续进行。 示例： 1234&lt;form action="/login" method="post"&gt; &lt;p&gt;&lt;input name="username" type="text" placeholder="用户名"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" type="password" placeholder="密码"&gt;&lt;/p&gt;&lt;/form&gt; [建议] 在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性。 解释： 根据内容类型指定输入框类型，能获得能友好的输入体验。 示例： 1&lt;input type="date"&gt; 7 多媒体 [建议] 当在现代浏览器中使用 audio 以及 video 标签来播放音频、视频时，应当注意格式。 解释： 音频应尽可能覆盖到如下格式： MP3 WAV Ogg 视频应尽可能覆盖到如下格式： MP4 WebM Ogg [建议] 在支持 HTML5 的浏览器中优先使用 audio 和 video 标签来定义音视频元素。 [建议] 使用退化到插件的方式来对多浏览器进行支持。 示例： 123456789101112131415&lt;audio controls&gt; &lt;source src="audio.mp3" type="audio/mpeg"&gt; &lt;source src="audio.ogg" type="audio/ogg"&gt; &lt;object width="100" height="50" data="audio.mp3"&gt; &lt;embed width="100" height="50" src="audio.swf"&gt; &lt;/object&gt;&lt;/audio&gt;&lt;video width="100" height="50" controls&gt; &lt;source src="video.mp4" type="video/mp4"&gt; &lt;source src="video.ogg" type="video/ogg"&gt; &lt;object width="100" height="50" data="video.mp4"&gt; &lt;embed width="100" height="50" src="video.swf"&gt; &lt;/object&gt;&lt;/video&gt; [建议] 只在必要的时候开启音视频的自动播放。 [建议] 在 object 标签内部提供指示浏览器不支持该标签的说明。 示例： 1&lt;object width="100" height="50" data="something.swf"&gt;DO NOT SUPPORT THIS TAG&lt;/object&gt; 8 模板中的 HTML [建议] 模板代码的缩进优先保证 HTML 代码的缩进规则。 示例： 123456789101112131415161718192021&lt;!-- good --&gt;&#123;if $display == true&#125;&lt;div&gt; &lt;ul&gt; &#123;foreach $item_list as $item&#125; &lt;li&gt;&#123;$item.name&#125;&lt;li&gt; &#123;/foreach&#125; &lt;/ul&gt;&lt;/div&gt;&#123;/if&#125;&lt;!-- bad --&gt;&#123;if $display == true&#125; &lt;div&gt; &lt;ul&gt; &#123;foreach $item_list as $item&#125; &lt;li&gt;&#123;$item.name&#125;&lt;li&gt; &#123;/foreach&#125; &lt;/ul&gt; &lt;/div&gt;&#123;/if&#125; [建议] 模板代码应以保证 HTML 单个标签语法的正确性为基本原则。 示例： 12345&lt;!-- good --&gt;&lt;li class="&#123;if $item.type_id == $current_type&#125;focus&#123;/if&#125;"&gt;&#123; $item.type_name &#125;&lt;/li&gt;&lt;!-- bad --&gt;&lt;li &#123;if $item.type_id == $current_type&#125; class="focus"&#123;/if&#125;&gt;&#123; $item.type_name &#125;&lt;/li&gt; [建议] 在循环处理模板数据构造表格时，若要求每行输出固定的个数，建议先将数据分组，之后再循环输出。 示例： 1234567891011121314151617181920212223&lt;!-- good --&gt;&lt;table&gt; &#123;foreach $item_list as $item_group&#125; &lt;tr&gt; &#123;foreach $item_group as $item&#125; &lt;td&gt;&#123; $item.name &#125;&lt;/td&gt; &#123;/foreach&#125; &lt;tr&gt; &#123;/foreach&#125;&lt;/table&gt;&lt;!-- bad --&gt;&lt;table&gt;&lt;tr&gt; &#123;foreach $item_list as $item&#125; &lt;td&gt;&#123; $item.name &#125;&lt;/td&gt; &#123;if $item@iteration is div by 5&#125; &lt;/tr&gt; &lt;tr&gt; &#123;/if&#125; &#123;/foreach&#125;&lt;/tr&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>开发规范</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 开发规范指导手册]]></title>
    <url>%2F2018%2F03%2F20%2Fcss-style-guide%2F</url>
    <content type="text"><![CDATA[1 背景 2 代码风格 2.1 文件 2.2 缩进 2.3 空格 2.4 行长度 2.5 选择器 2.6 属性 3 通用 3.1 选择器 3.2 属性缩写 3.3 属性书写顺序 3.4 清除浮动 3.5 !important 3.6 z-index 4 值与单位 4.1 文本 4.2 数值 4.3 url() 4.4 长度 4.5 颜色 4.6 2D 位置 5 文本编排 5.1 字体族 5.2 字号 5.3 字体风格 5.4 字重 5.5 行高 6 变换与动画 7 响应式 8 兼容性 8.1 属性前缀 8.2 Hack 8.3 Expression 1 背景 转自。 CSS 作为网页样式的描述语言，在百度一直有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。 虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。 2 代码风格 2.1 文件 [建议] CSS 文件使用无 BOM 的 UTF-8 编码。 解释： UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。 2.2 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 示例： 1234.selector &#123; margin: 0; padding: 0;&#125; 2.3 空格 [强制] 选择器 与 { 之间必须包含空格。 示例： 12.selector &#123;&#125; [强制] 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例： 1margin: 0; [强制] 列表型属性值 书写在单行时，, 后必须跟一个空格。 示例： 1font-family: Arial, sans-serif; 2.4 行长度 [强制] 每行不得超过 120 个字符，除非单行不可分割。 解释： 常见不可分割的场景为URL超长。 [建议] 对于超长的样式，在样式值的 空格 处或 , 后换行，建议按逻辑分组。 示例： 123456789101112131415161718/* 不同属性值按逻辑分组 */background: transparent url(aVeryVeryVeryLongUrlIsPlacedHere) no-repeat 0 0;/* 可重复多次的属性，每次重复一行 */background-image: url(aVeryVeryVeryLongUrlIsPlacedHere) url(anotherVeryVeryVeryLongUrlIsPlacedHere);/* 类似函数的属性值可以根据函数调用的缩进进行 */background-image: -webkit-gradient( linear, left bottom, left top, color-stop(0.04, rgb(88,94,124)), color-stop(0.52, rgb(115,123,162))); 2.5 选择器 [强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。 示例： 1234567891011/* good */.post,.page,.comment &#123; line-height: 1.5;&#125;/* bad */.post, .page, .comment &#123; line-height: 1.5;&#125; [强制] &gt;、+、~ 选择器的两边各保留一个空格。 示例： 12345678910111213141516171819202122232425/* good */main &gt; nav &#123; padding: 10px;&#125;label + input &#123; margin-left: 5px;&#125;input:checked ~ button &#123; background-color: #69C;&#125;/* bad */main&gt;nav &#123; padding: 10px;&#125;label+input &#123; margin-left: 5px;&#125;input:checked~button &#123; background-color: #69C;&#125; [强制] 属性选择器中的值必须用双引号包围。 解释： 不允许使用单引号，不允许不使用引号。 示例： 123456789/* good */article[character="juliet"] &#123; voice-family: "Vivien Leigh", victoria, female;&#125;/* bad */article[character='juliet'] &#123; voice-family: "Vivien Leigh", victoria, female;&#125; 2.6 属性 [强制] 属性定义必须另起一行。 示例： 12345678/* good */.selector &#123; margin: 0; padding: 0;&#125;/* bad */.selector &#123; margin: 0; padding: 0; &#125; [强制] 属性定义后必须以分号结尾。 示例： 123456789/* good */.selector &#123; margin: 0;&#125;/* bad */.selector &#123; margin: 0&#125; 3 通用 3.1 选择器 [强制] 如无必要，不得为 id、class 选择器添加类型选择器进行限定。 解释： 在性能和维护性上，都有一定的影响。 示例： 1234567891011/* good */#error,.danger-message &#123; font-color: #c00;&#125;/* bad */dialog#error,p.danger-message &#123; font-color: #c00;&#125; [建议] 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例： 1234567/* good */#username input &#123;&#125;.comment .avatar &#123;&#125;/* bad */.page .header .login #username input &#123;&#125;.comment div * &#123;&#125; 3.2 属性缩写 [建议] 在可以使用缩写的情况下，尽量使用属性缩写。 示例： 1234567891011/* good */.post &#123; font: 12px/1.5 arial, sans-serif;&#125;/* bad */.post &#123; font-family: arial, sans-serif; font-size: 12px; line-height: 1.5;&#125; [建议] 使用 border / margin / padding 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。 解释： border / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。 示例： 123456789101112131415161718192021222324/* centering &lt;article class="page"&gt; horizontally and highlight featured ones */article &#123; margin: 5px; border: 1px solid #999;&#125;/* good */.page &#123; margin-right: auto; margin-left: auto;&#125;.featured &#123; border-color: #69c;&#125;/* bad */.page &#123; margin: 5px auto; /* introducing redundancy */&#125;.featured &#123; border: 1px solid #69c; /* introducing redundancy */&#125; 3.3 属性书写顺序 [建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。 解释： Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等 另外，如果包含 content 属性，应放在最前面。 示例： 1234567891011121314151617181920212223.sidebar &#123; /* formatting model: positioning schemes / offsets / z-indexes / display / ... */ position: absolute; top: 50px; left: 0; overflow-x: hidden; /* box model: sizes / margins / paddings / borders / ... */ width: 200px; padding: 5px; border: 1px solid #ddd; /* typographic: font / aligns / text styles / ... */ font-size: 14px; line-height: 20px; /* visual: colors / shadows / gradients / ... */ background: #f5f5f5; color: #333; -webkit-transition: color 1s; -moz-transition: color 1s; transition: color 1s;&#125; 3.4 清除浮动 [建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。 解释： 触发 BFC 的方式很多，常见的有： float 非 none position 非 static overflow 非 visible 如希望使用更小副作用的清除浮动方法，参见 A new micro clearfix hack 一文。 另需注意，对已经触发 BFC 的元素不需要再进行 clearfix。 3.5 !important [建议] 尽量不使用 !important 声明。 [建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 !important 定义样式。 解释： 必须注意的是，仅在设计上 确实不允许任何其它场景覆盖样式 时，才使用内联的 !important 样式。通常在第三方环境的应用中使用这种方案。下面的 z-index 章节是其中一个特殊场景的典型样例。 3.6 z-index [建议] 将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。 解释： 同层的多个元素，如多个由用户输入触发的 Dialog，在该层级内使用相同的 z-index 或递增 z-index。 建议每层包含100个 z-index 来容纳足够的元素，如果每层元素较多，可以调整这个数值。 [建议] 在可控环境下，期望显示在最上层的元素，z-index 指定为 999999。 解释： 可控环境分成两种，一种是自身产品线环境；还有一种是可能会被其他产品线引用，但是不会被外部第三方的产品引用。 不建议取值为 2147483647。以便于自身产品线被其他产品线引用时，当遇到层级覆盖冲突的情况，留出向上调整的空间。 [建议] 在第三方环境下，期望显示在最上层的元素，通过标签内联和 !important，将 z-index 指定为 2147483647。 解释： 第三方环境对于开发者来说完全不可控。在第三方环境下的元素，为了保证元素不被其页面其他样式定义覆盖，需要采用此做法。 4 值与单位 4.1 文本 [强制] 文本内容必须用双引号包围。 解释： 文本类型的内容可能在选择器、属性值等内容中。 示例： 123456789101112131415161718192021/* good */html[lang|="zh"] q:before &#123; font-family: "Microsoft YaHei", sans-serif; content: "“";&#125;html[lang|="zh"] q:after &#123; font-family: "Microsoft YaHei", sans-serif; content: "”";&#125;/* bad */html[lang|=zh] q:before &#123; font-family: 'Microsoft YaHei', sans-serif; content: '“';&#125;html[lang|=zh] q:after &#123; font-family: "Microsoft YaHei", sans-serif; content: "”";&#125; 4.2 数值 [强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 0。 示例： 123456789/* good */panel &#123; opacity: .8;&#125;/* bad */panel &#123; opacity: 0.8;&#125; 4.3 url() [强制] url() 函数中的路径不加引号。 示例： 123body &#123; background: url(bg.png);&#125; [建议] url() 函数中的绝对路径可省去协议名。 示例： 123body &#123; background: url(//baidu.com/img/bg.png) no-repeat 0 0;&#125; 4.4 长度 [强制] 长度为 0 时须省略单位。 (也只有长度单位可省) 示例： 123456789/* good */body &#123; padding: 0 5px;&#125;/* bad */body &#123; padding: 0px 5px;&#125; 4.5 颜色 [强制] RGB颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。 解释： 带有alpha的颜色信息可以使用 rgba()。使用 rgba() 时每个逗号后必须保留一个空格。 示例： 1234567891011/* good */.success &#123; box-shadow: 0 0 2px rgba(0, 128, 0, .3); border-color: #008000;&#125;/* bad */.success &#123; box-shadow: 0 0 2px rgba(0,128,0,.3); border-color: rgb(0, 128, 0);&#125; [强制] 颜色值可以缩写时，必须使用缩写形式。 示例： 123456789/* good */.success &#123; background-color: #aca;&#125;/* bad */.success &#123; background-color: #aaccaa;&#125; [强制] 颜色值不允许使用命名色值。 示例： 123456789/* good */.success &#123; color: #90ee90;&#125;/* bad */.success &#123; color: lightgreen;&#125; [建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。 示例： 1234567891011121314151617/* good */.success &#123; background-color: #aca; color: #90ee90;&#125;/* good */.success &#123; background-color: #ACA; color: #90EE90;&#125;/* bad */.success &#123; background-color: #ACA; color: #90ee90;&#125; 4.6 2D 位置 [强制] 必须同时给出水平和垂直方向的位置。 解释： 2D 位置初始值为 0% 0%，但在只有一个方向的值时，另一个方向的值会被解析为 center。为避免理解上的困扰，应同时给出两个方向的值。background-position属性值的定义 示例： 123456789/* good */body &#123; background-position: center top; /* 50% 0% */&#125;/* bad */body &#123; background-position: top; /* 50% 0% */&#125; 5 文本编排 5.1 字体族 [强制] font-family 属性中的字体族名称应使用字体的英文 Family Name，其中如有空格，须放置在引号中。 解释： 所谓英文 Family Name，为字体文件的一个元数据，常见名称如下： 字体 操作系统 Family Name 宋体 (中易宋体) Windows SimSun 黑体 (中易黑体) Windows SimHei 微软雅黑 Windows Microsoft YaHei 微软正黑 Windows Microsoft JhengHei 华文黑体 Mac/iOS STHeiti 冬青黑体 Mac/iOS Hiragino Sans GB 文泉驿正黑 Linux WenQuanYi Zen Hei 文泉驿微米黑 Linux WenQuanYi Micro Hei 示例： 123h1 &#123; font-family: "Microsoft YaHei";&#125; [强制] font-family 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif )。 解释： 更详细说明可参考本文。 示例： 123456789/* Display according to platform */.article &#123; font-family: Arial, sans-serif;&#125;/* Specific for most platforms */h1 &#123; font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", "WenQuanYi Micro Hei", "Microsoft YaHei", sans-serif;&#125; [强制] font-family 不区分大小写，但在同一个项目中，同样的 Family Name 大小写必须统一。 示例： 1234567891011121314151617/* good */body &#123; font-family: Arial, sans-serif;&#125;h1 &#123; font-family: Arial, "Microsoft YaHei", sans-serif;&#125;/* bad */body &#123; font-family: arial, sans-serif;&#125;h1 &#123; font-family: Arial, "Microsoft YaHei", sans-serif;&#125; 5.2 字号 [强制] 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。 解释： 由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。 5.3 字体风格 [建议] 需要在 Windows 平台显示的中文内容，不要使用除 normal 外的 font-style。其他平台也应慎用。 解释： 由于中文字体没有 italic 风格的实现，所有浏览器下都会 fallback 到 obilique 实现 (自动拟合为斜体)，小字号下 (特别是 Windows 下会在小字号下使用点阵字体的情况下) 显示效果差，造成阅读困难。 5.4 字重 [强制] font-weight 属性必须使用数值方式描述。 解释： CSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。 浏览器本身使用一系列启发式规则来进行匹配，在 &lt;700 时一般匹配字体的 Regular 字重，&gt;=700 时匹配 Bold 字重。 但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见此表)，故使用数值描述增加了灵活性，也更简短。 示例： 123456789/* good */h1 &#123; font-weight: 700;&#125;/* bad */h1 &#123; font-weight: bold;&#125; 5.5 行高 [建议] line-height 在定义文本段落时，应使用数值。 解释： 将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。 当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。 示例： 123.container &#123; line-height: 1.5;&#125; 6 变换与动画 [强制] 使用 transition 时应指定 transition-property。 示例： 123456789/* good */.box &#123; transition: color 1s, border-color 1s;&#125;/* bad */.box &#123; transition: all 1s;&#125; [建议] 尽可能在浏览器能高效实现的属性上添加过渡和动画。 解释： 见本文，在可能的情况下应选择这样四种变换： transform: translate(npx, npx); transform: scale(n); transform: rotate(ndeg); opacity: 0..1; 典型的，可以使用 translate 来代替 left 作为动画属性。 示例： 12345678910111213141516/* good */.box &#123; transition: transform 1s;&#125;.box:hover &#123; transform: translate(20px); /* move right for 20px */&#125;/* bad */.box &#123; left: 0; transition: left 1s;&#125;.box:hover &#123; left: 20px; /* move right for 20px */&#125; 7 响应式 [强制] Media Query 不得单独编排，必须与相关的规则一起定义。 示例： 1234567891011121314151617181920212223242526/* Good *//* header styles */@media (...) &#123; /* header styles */&#125;/* main styles */@media (...) &#123; /* main styles */&#125;/* footer styles */@media (...) &#123; /* footer styles */&#125;/* Bad *//* header styles *//* main styles *//* footer styles */@media (...) &#123; /* header styles */ /* main styles */ /* footer styles */&#125; [强制] Media Query 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。 示例： 1234567@media(-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */(min--moz-device-pixel-ratio: 2), /* Older Firefox browsers (prior to Firefox 16) */(min-resolution: 2dppx), /* The standard way */(min-resolution: 192dpi) &#123; /* dppx fallback */ /* Retina-specific stuff here */&#125; [建议] 尽可能给出在高分辨率设备 (Retina) 下效果更佳的样式。 8 兼容性 8.1 属性前缀 [强制] 带私有前缀的属性由长到短排列，按冒号位置对齐。 解释： 标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。 示例： 12345.box &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 8.2 Hack [建议] 需要添加 hack 时应尽可能考虑是否可以采用其他方式解决。 解释： 如果能通过合理的 HTML 结构或使用其他的 CSS 定义达到理想的样式，则不应该使用 hack 手段解决问题。通常 hack 会导致维护成本的增加。 [建议] 尽量使用 选择器 hack 处理兼容性，而非 属性 hack。 解释： 尽量使用符合 CSS 语法的 selector hack，可以避免一些第三方库无法识别 hack 语法的问题。 示例： 1234567891011/* IE 7 */*:first-child + html #header &#123; margin-top: 3px; padding: 5px;&#125;/* IE 6 */* html #header &#123; margin-top: 5px; padding: 4px;&#125; [建议] 尽量使用简单的 属性 hack。 示例： 12345678910.box &#123; _display: inline; /* fix double margin */ float: left; margin-left: 20px;&#125;.container &#123; overflow: hidden; *zoom: 1; /* triggering hasLayout */&#125; 8.3 Expression [强制] 禁止使用 Expression。]]></content>
      <categories>
        <category>开发规范</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 开发规范指导手册]]></title>
    <url>%2F2018%2F03%2F13%2Fjs-style-guide%2F</url>
    <content type="text"><![CDATA[1 背景 2 代码风格 2.1 文件 2.2 结构 2.2.1 缩进 2.2.2 空格 2.2.3 换行 2.2.4 语句 2.2.5 块 2.2.6 逗号 2.2.7 分号 2.3 命名 2.4 注释 2.4.1 单行注释 2.4.2 多行注释 2.4.3 文档化注释 2.4.4 类型定义 2.4.5 文件注释 2.4.6 命名空间注释 2.4.7 类注释 2.4.8 函数/方法注释 2.4.9 事件注释 2.4.10 常量注释 2.4.11 复杂类型注释 2.4.12 AMD 模块注释 2.4.13 细节注释 3 语言特性 3.1 变量 3.2 条件 3.3 循环 3.4 类型 3.4.1 类型检测 3.4.2 类型转换 3.5 字符串 3.6 对象 3.7 数组 3.8 函数 3.8.1 函数表达式 3.8.2 函数长度 3.8.3 参数设计 3.8.4 闭包 3.8.5 空函数 3.9 面向对象 3.10 动态特性 3.10.1 eval 3.10.2 动态执行代码 3.10.3 with 3.10.4 delete 3.10.5 对象属性 3.11 存取器 4 浏览器环境 4.1 模块化 4.1.1 AMD 4.1.2 define 4.1.3 require 4.2 DOM 4.2.1 元素获取 4.2.2 样式获取 4.2.3 样式设置 4.2.4 DOM 操作 4.2.5 DOM 事件 5 jQuery 5.1 jQuery 变量 5.2 选择器 5.3 DOM 操作 5.4 事件 5.5 Ajax 5.6 链式写法 1 背景 在前端项目开发中，JavaScript 的应用特别广泛，而为了让代码更具可读性，好的代码风格显示尤为重要。 虽然本文档是针对JavaScript设计的，但是在使用各种JavaScript的预编译语言时(如ES6，TypeScript等)时，适用的部分也应尽量遵循本文档的约定。 2 代码风格 2.1 文件 [建议] JavaScript 文件使用无 BOM 的 UTF-8 编码。 解释： UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。 [建议] 在文件结尾处，保留一个空行。 2.2 结构 2.2.1 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 [强制] switch 下的 case 和 default 必须增加一个缩进层级。 示例： 12345678910111213141516171819202122232425262728293031// goodswitch (variable) &#123; case '1': // do... break; case '2': // do... break; default: // do...&#125;// badswitch (variable) &#123;case '1': // do... break;case '2': // do... break;default: // do...&#125; 2.2.2 空格 [强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。 示例： 123var a = !arr.length;a++;a = b + c; [强制] 用作代码块起始的左花括号 { 前必须有一个空格。 示例： 12345678910111213141516171819// goodif (condition) &#123;&#125;while (condition) &#123;&#125;function funcName() &#123;&#125;// badif (condition)&#123;&#125;while (condition)&#123;&#125;function funcName()&#123;&#125; [强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。 示例： 12345678910111213141516171819// goodif (condition) &#123;&#125;while (condition) &#123;&#125;(function () &#123;&#125;)();// badif(condition) &#123;&#125;while(condition) &#123;&#125;(function() &#123;&#125;)(); [强制] 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。 示例： 12345678910111213// goodvar obj = &#123; a: 1, b: 2, c: 3&#125;;// badvar obj = &#123; a : 1, b:2, c :3&#125;; [强制] 函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。 示例： 1234567891011121314151617// goodfunction funcName() &#123;&#125;var funcName = function funcName() &#123;&#125;;funcName();// badfunction funcName () &#123;&#125;var funcName = function funcName () &#123;&#125;;funcName (); [强制] , 和 ; 前不允许有空格。 示例： 12345// goodcallFunc(a, b);// badcallFunc(a , b) ; [强制] 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。 示例： 1234567891011121314151617181920212223242526// goodcallFunc(param1, param2, param3);save(this.list[this.indexes[i]]);needIncream &amp;&amp; (variable += increament);if (num &gt; list.length) &#123;&#125;while (len--) &#123;&#125;// badcallFunc( param1, param2, param3 );save( this.list[ this.indexes[ i ] ] );needIncreament &amp;&amp; ( variable += increament );if ( num &gt; list.length ) &#123;&#125;while ( len-- ) &#123;&#125; [强制] 单行声明的数组与对象，如果包含元素，{} 和 [] 内紧贴括号部分不允许包含空格。 解释： 声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。 示例： 1234567891011121314151617// goodvar arr1 = [];var arr2 = [1, 2, 3];var obj1 = &#123;&#125;;var obj2 = &#123;name: 'obj'&#125;;var obj3 = &#123; name: 'obj', age: 20, sex: 1&#125;;// badvar arr1 = [ ];var arr2 = [ 1, 2, 3 ];var obj1 = &#123; &#125;;var obj2 = &#123; name: 'obj' &#125;;var obj3 = &#123;name: 'obj', age: 20, sex: 1&#125;; [强制] 行尾不得有多余的空格。 2.2.3 换行 [强制] 每个独立语句结束后必须换行。 [强制] 每行不得超过 120 个字符。 解释： 超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。 [强制] 运算符处换行时，运算符必须在新行的行首。 示例： 1234567891011121314151617181920212223// goodif (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) &#123; // Code&#125;var result = number1 + number2 + number3 + number4 + number5;// badif (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) &#123; // Code&#125;var result = number1 + number2 + number3 + number4 + number5; [强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、for语句等场景中，不允许在 , 或 ; 前换行。 示例： 1234567891011121314151617181920212223242526// goodvar obj = &#123; a: 1, b: 2, c: 3&#125;;foo( aVeryVeryLongArgument, anotherVeryLongArgument, callback);// badvar obj = &#123; a: 1 , b: 2 , c: 3&#125;;foo( aVeryVeryLongArgument , anotherVeryLongArgument , callback); [建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。 示例： 12345678// 仅为按逻辑换行的示例，不代表setStyle的最优实现function setStyle(element, property, value) &#123; if (element == null) &#123; return; &#125; element.style[property] = value;&#125; [建议] 在语句的行长度超过 120 时，根据逻辑条件合理缩进。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。// 建议最终将右括号 ) 与左大括号 &#123; 放在独立一行，保证与 if 内语句块能容易视觉辨识。if (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) &#123; // Code&#125;// 按一定长度截断字符串，并使用 + 运算符进行连接。// 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。// 特别的，对于HTML片段的拼接，通过缩进，保持和HTML相同的结构。var html = '' // 此处用一个空字符串，以便整个HTML片段都在新行严格对齐 + '&lt;article&gt;' + '&lt;h1&gt;Title here&lt;/h1&gt;' + '&lt;p&gt;This is a paragraph&lt;/p&gt;' + '&lt;footer&gt;Complete&lt;/footer&gt;' + '&lt;/article&gt;';// 也可使用数组来进行拼接，相对 + 更容易调整缩进。var html = [ '&lt;article&gt;', '&lt;h1&gt;Title here&lt;/h1&gt;', '&lt;p&gt;This is a paragraph&lt;/p&gt;', '&lt;footer&gt;Complete&lt;/footer&gt;', '&lt;/article&gt;'];html = html.join('');// 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。// 所有参数必须增加一个缩进。foo( aVeryVeryLongArgument, anotherVeryLongArgument, callback);// 也可以按逻辑对参数进行组合。// 最经典的是baidu.format函数，调用时将参数分为“模板”和“数据”两块baidu.format( dateFormatTemplate, year, month, date, hour, minute, second);// 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。// 这通常出现在匿名函数或者对象初始化等作为参数时，如setTimeout函数等。setTimeout( function () &#123; alert('hello'); &#125;, 200);order.data.read( 'id=' + me.model.id, function (data) &#123; me.attchToModel(data.result); callback(); &#125;, 300);// 链式调用较长时采用缩进进行调整。$('#items') .find('.selected') .highlight() .end();// 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。var result = thisIsAVeryVeryLongCondition ? resultA : resultB;var result = condition ? thisIsAVeryVeryLongResult : resultB;// 数组和对象初始化的混用，严格按照每个对象的 &#123; 和结束 &#125; 在独立一行的风格书写。var array = [ &#123; // ... &#125;, &#123; // ... &#125;]; [建议] 对于 if...else...、try...catch...finally 等语句，推荐使用在 } 号后添加一个换行 的风格，使代码层次结构更清晰，阅读性更好。 示例： 12345678910111213if (condition) &#123; // some statements;&#125;else &#123; // some statements;&#125;try &#123; // some statements;&#125;catch (ex) &#123; // some statements;&#125; [强制] 在使用长方法链时进行换行缩进。使用前面的 . 强调这是方法调用，而不是新语句。 示例： 12345678910111213141516171819202122232425262728293031323334// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodvar leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 2.2.4 语句 [强制] 不得省略语句结束的分号。 [强制] 在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 {...}。 示例： 123456789// goodif (condition) &#123; callFunc();&#125;// badif (condition) callFunc();if (condition) callFunc(); [强制] 函数定义结束不允许添加分号。 示例： 1234567891011// goodfunction funcName() &#123;&#125;// badfunction funcName() &#123;&#125;;// 如果是函数表达式，分号是不允许省略的。var funcName = function () &#123;&#125;; [强制] IIFE 必须在函数表达式外添加 (，非 IIFE 不得在函数表达式外添加 (。 解释： IIFE = Immediately-Invoked Function Expression. 额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。 示例： 123456789101112131415161718// goodvar task = (function () &#123; // Code return result;&#125;)();var func = function () &#123;&#125;;// badvar task = function () &#123; // Code return result;&#125;();var func = (function () &#123;&#125;); 2.2.5 块 [强制] 使用大括号包裹所有的多行代码块。 示例： 12345678910111213141516// badif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction testFun() &#123; return false; &#125;// goodfunction testFun() &#123; return false;&#125; [强制] 在块末和新语句前插入空行。 示例： 1234567891011121314151617181920212223242526272829303132// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badvar obj = &#123; foo: function () &#123; &#125;, bar: function () &#123; &#125;&#125;;return obj;// goodvar obj = &#123; foo: function () &#123; &#125;, bar: function () &#123; &#125;&#125;;return obj; 2.2.6 逗号 [强制] 禁止行首逗号。 示例： 1234567891011121314151617181920212223242526272829// badvar story = [ once , upon , aTime];// goodvar story = [ once, upon, aTime];// badvar hero = &#123; firstName: 'Bob' , lastName: 'Parr' , heroName: 'Mr. Incredible' , superPower: 'strength'&#125;;// goodvar hero = &#123; firstName: 'Bob', lastName: 'Parr', heroName: 'Mr. Incredible', superPower: 'strength'&#125;; [强制] 禁止额外的行末逗号。 解释： 行末逗号，会在 IE6/7 和 IE9 怪异模式下引下问题，多余的逗号在某些 ES3 的实现里会增加数组的长度。在 ES5 中已经澄清。 Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this. 示例： 123456789101112131415161718192021// badvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn',&#125;;var heroes = [ 'Batman', 'Superman',];// goodvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn'&#125;;var heroes = [ 'Batman', 'Superman']; 2.2.7 分号 [强制] 语句结束必须使用分号。 示例： 1234567891011121314151617// bad(function () &#123; var name = 'Skywalker' return name&#125;)()// good(function () &#123; var name = 'Skywalker'; return name;&#125;)();// good (防止函数在两个 IIFE 合并时被当成一个参数;(function () &#123; var name = 'Skywalker'; return name;&#125;)(); 2.3 命名 [强制] 变量 使用 Camel命名法。 示例： 1var loadingModules = &#123;&#125;; [强制] 常量 使用 全部字母大写，单词间下划线分隔 的命名方式。 示例： 1var HTML_ENTITY = &#123;&#125;; [强制] 函数 使用 Camel命名法。 示例： 12function stringFormat(source) &#123;&#125; [强制] 函数的 参数 使用 Camel命名法。 示例： 12function hear(theBells) &#123;&#125; [强制] 类 使用 Pascal命名法。 示例： 12function TextNode(options) &#123;&#125; [强制] 类的 方法 / 属性 使用 Camel命名法。 示例： 12345678function TextNode(value, engine) &#123; this.value = value; this.engine = engine;&#125;TextNode.prototype.clone = function () &#123; return this;&#125;; [强制] 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。 示例： 123456var TargetState = &#123; READING: 1, READED: 2, APPLIED: 3, READY: 4&#125;; [强制] 命名空间 使用 Camel命名法。 示例： 1equipments.heavyWeapons = &#123;&#125;; [强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。 示例： 1234567function XMLParser() &#123;&#125;function insertHTML(element, html) &#123;&#125;var httpRequest = new HTTPRequest(); [强制] 类名 使用 名词。 示例： 12function Engine(options) &#123;&#125; [建议] 函数名 使用 动宾短语。 示例： 12function getStyle(element) &#123;&#125; [建议] boolean 类型的变量使用 is 或 has 开头。 示例： 12var isReady = false;var hasMoreCommands = false; [建议] Promise对象 用 动宾短语的进行时 表达。 示例： 12var loadingData = ajax.get('url');loadingData.then(callback); [建议] 不要使用下划线前/后缀。 解释： JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。 也就是说：如果你想要某处为「私有」，它必须不能是显式提出的。 示例： 1234567// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; [建议] 不保存 this 的引用，使用 Function#bind 。 解释： 让代码变得更加简洁，避免了很多不必要的变量（存放上文this）。 示例： 123456789101112131415161718192021222324252627282930// badfunction testFun() &#123; var self = this; return function () &#123; console.log(self); &#125;;&#125;// badfunction testFun() &#123; var that = this; return function () &#123; console.log(that); &#125;;&#125;// badfunction testFun() &#123; var _this = this; return function () &#123; console.log(_this); &#125;;&#125;// goodfunction testFun() &#123; return function () &#123; console.log(this); &#125;.bind(this);&#125; [建议] 如果文件导出一个类，文件名应该与类名完全相同。 示例： 123456789101112131415// file contentsclass CheckBox &#123; // ...&#125;module.exports = CheckBox;// in some other file// badvar CheckBox = require('./checkBox');// badvar CheckBox = require('./check_box');// goodvar CheckBox = require('./CheckBox'); 2.4 注释 2.4.1 单行注释 [强制] 必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。 2.4.2 多行注释 [建议] 避免使用 /*...*/ 这样的多行注释。有多行注释内容时，使用多个单行注释。 2.4.3 文档化注释 [强制] 为了便于代码阅读和自文档化，以下内容必须包含以 /**...*/ 形式的块注释中。 解释： 文件 namespace 类 函数或方法 类属性 事件 全局变量 常量 AMD 模块 [强制] 文档注释前必须空一行。 [建议] 自文档化的文档说明 what，而不是 how。 2.4.4 类型定义 [强制] 类型定义都是以{开始, 以}结束。 解释： 常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。 类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。 [强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。 类型定义 语法示例 解释 String {string} – Number {number} – Boolean {boolean} – Object {Object} – Function {Function} – RegExp {RegExp} – Array {Array} – Date {Date} – 单一类型集合 {Array.&lt;string&gt;} string 类型的数组 多类型 {(number｜boolean)} 可能是 number 类型, 也可能是 boolean 类型 允许为null {?number} 可能是 number, 也可能是 null 不允许为null {!Object} Object 类型, 但不是 null Function类型 {function(number, boolean)} 函数, 形参类型 Function带返回值 {function(number, boolean):string} 函数, 形参, 返回值类型 参数可选 @param {string=} name 可选参数, =为类型后缀 可变参数 @param {…number} args 变长参数, …为类型前缀 任意类型 {*} 任意类型 可选任意类型 @param {*=} name 可选参数，类型不限 可变任意类型 @param {…*} args 变长参数，类型不限 2.4.5 文件注释 [强制] 文件顶部必须包含文件注释，用 @file 标识文件说明。 示例： 123/** * @file Describe the file */ [建议] 文件注释中可以用 @author 标识开发者信息。 解释： 开发者信息能够体现开发人员对文件的贡献，并且能够让遇到问题或希望了解相关信息的人找到维护人。通常情况文件在被创建时标识的是创建者。随着项目的进展，越来越多的人加入，参与这个文件的开发，新的作者应该被加入 @author 标识。 @author 标识具有多人时，原则是按照 责任 进行排序。通常的说就是如果有问题，就是找第一个人应该比找第二个人有效。比如文件的创建者由于各种原因，模块移交给了其他人或其他团队，后来因为新增需求，其他人在新增代码时，添加 @author 标识应该把自己的名字添加在创建人的前面。 @author 中的名字不允许被删除。任何劳动成果都应该被尊重。 业务项目中，一个文件可能被多人频繁修改，并且每个人的维护时间都可能不会很长，不建议为文件增加 @author 标识。通过版本控制系统追踪变更，按业务逻辑单元确定模块的维护责任人，通过文档与wiki跟踪和查询，是更好的责任管理方式。 对于业务逻辑无关的技术型基础项目，特别是开源的公共项目，应使用 @author 标识。 示例： 12345/** * @file Describe the file * @author author-name(mail-name@domain.com) * author-name2(mail-name2@domain.com) */ 2.4.6 命名空间注释 [建议] 命名空间使用 @namespace 标识。 示例： 1234/** * @namespace */var util = &#123;&#125;; 2.4.7 类注释 [建议] 使用 @class 标记类或构造函数。 解释： 对于使用对象 constructor 属性来定义的构造函数，可以使用 @constructor 来标记。 示例： 12345678/** * 描述 * * @class */function Developer() &#123; // constructor body&#125; [建议] 使用 @extends 标记类的继承信息。 示例： 1234567891011/** * 描述 * * @class * @extends Developer */function Fronteer() &#123; Developer.call(this); // constructor body&#125;util.inherits(Fronteer, Developer); [强制] 使用包装方式扩展类成员时， 必须通过 @lends 进行重新指向。 解释： 没有 @lends 标记将无法为该类生成包含扩展类成员的文档。 示例： 12345678910111213141516171819/** * 类描述 * * @class * @extends Developer */function Fronteer() &#123; Developer.call(this); // constructor body&#125;util.extend( Fronteer.prototype, /** @lends Fronteer.prototype */&#123; _getLevel: function () &#123; // TODO &#125; &#125;); [强制] 类的属性或方法等成员信息使用 @public / @protected / @private 中的任意一个，指明可访问性。 解释： 生成的文档中将有可访问性的标记，避免用户直接使用非 public 的属性或方法。 示例： 1234567891011121314151617181920212223242526272829/** * 类描述 * * @class * @extends Developer */var Fronteer = function () &#123; Developer.call(this); /** * 属性描述 * * @type &#123;string&#125; * @private */ this._level = 'T12'; // constructor body&#125;;util.inherits(Fronteer, Developer);/** * 方法描述 * * @private * @return &#123;string&#125; 返回值描述 */Fronteer.prototype._getLevel = function () &#123;&#125;; 2.4.8 函数/方法注释 [强制] 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。 [强制] 参数和返回值注释必须包含类型信息和说明。 [建议] 当函数是内部函数，外部不可访问时，可以使用 @inner 标识。 示例： 1234567891011121314151617/** * 函数描述 * * @param &#123;string&#125; p1 参数1的说明 * @param &#123;string&#125; p2 参数2的说明，比较长 * 那就换行了. * @param &#123;number=&#125; p3 参数3的说明（可选） * @return &#123;Object&#125; 返回值描述 */function foo(p1, p2, p3) &#123; var p3 = p3 || 10; return &#123; p1: p1, p2: p2, p3: p3 &#125;;&#125; [强制] 对 Object 中各项的描述， 必须使用 @param 标识。 示例： 12345678910/** * 函数描述 * * @param &#123;Object&#125; option 参数描述 * @param &#123;string&#125; option.url option项描述 * @param &#123;string=&#125; option.method option项描述，可选参数 */function foo(option) &#123; // TODO&#125; [建议] 重写父类方法时， 应当添加 @override 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 @param、@return，仅用 @override 标识，否则仍应作完整注释。 解释： 简而言之，当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。 2.4.9 事件注释 [强制] 必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同。 示例： 12345678910/** * 值变更时触发 * * @event * @param &#123;Object&#125; e e描述 * @param &#123;string&#125; e.before before描述 * @param &#123;string&#125; e.after after描述 */onchange: function (e) &#123;&#125; [强制] 在会广播事件的函数前使用 @fires 标识广播的事件，在广播事件代码前使用 @event 标识事件。 [建议] 对于事件对象的注释，使用 @param 标识，生成文档时可读性更好。 示例： 1234567891011121314151617181920212223/** * 点击处理 * * @fires Select#change * @private */Select.prototype.clickHandler = function () &#123; /** * 值变更时触发 * * @event Select#change * @param &#123;Object&#125; e e描述 * @param &#123;string&#125; e.before before描述 * @param &#123;string&#125; e.after after描述 */ this.fire( 'change', &#123; before: 'foo', after: 'bar' &#125; );&#125;; 2.4.10 常量注释 [强制] 常量必须使用 @const 标记，并包含说明和类型信息。 示例： 1234567/** * 常量说明 * * @const * @type &#123;string&#125; */var REQUEST_URL = 'myurl.do'; 2.4.11 复杂类型注释 [建议] 对于类型未定义的复杂结构的注释，可以使用 @typedef 标识来定义。 示例： 123456789101112131415161718192021222324// `namespaceA~` 可以换成其它 namepaths 前缀，目的是为了生成文档中能显示 `@typedef` 定义的类型和链接。/** * 服务器 * * @typedef &#123;Object&#125; namespaceA~Server * @property &#123;string&#125; host 主机 * @property &#123;number&#125; port 端口 *//** * 服务器列表 * * @type &#123;Array.&lt;namespaceA~Server&gt;&#125; */var servers = [ &#123; host: '1.2.3.4', port: 8080 &#125;, &#123; host: '1.2.3.5', port: 8081 &#125;]; 2.4.12 AMD 模块注释 [强制] AMD 模块使用 @module 或 @exports 标识。 解释： @exports 与 @module 都可以用来标识模块，区别在于 @module 可以省略模块名称。而只使用 @exports 时在 namepaths 中可以省略 module: 前缀。 示例： 12345678910111213141516171819202122232425define( function (require) &#123; /** * foo description * * @exports Foo */ var foo = &#123; // TODO &#125;; /** * baz description * * @return &#123;boolean&#125; return description */ foo.baz = function () &#123; // TODO &#125;; return foo; &#125;); 也可以在 exports 变量前使用 @module 标识： 12345678910111213141516171819202122define( function (require) &#123; /** * module description. * * @module foo */ var exports = &#123;&#125;; /** * bar description * */ exports.bar = function () &#123; // TODO &#125;; return exports; &#125;); 如果直接使用 factory 的 exports 参数，还可以： 123456789101112131415161718/** * module description. * * @module */define( function (require, exports) &#123; /** * bar description * */ exports.bar = function () &#123; // TODO &#125;; return exports; &#125;); [强制] 对于已使用 @module 标识为 AMD模块 的引用，在 namepaths 中必须增加 module: 作前缀。 解释： namepaths 没有 module: 前缀时，生成的文档中将无法正确生成链接。 示例： 1234567891011121314151617181920212223/** * 点击处理 * * @fires module:Select#change * @private */Select.prototype.clickHandler = function () &#123; /** * 值变更时触发 * * @event module:Select#change * @param &#123;Object&#125; e e描述 * @param &#123;string&#125; e.before before描述 * @param &#123;string&#125; e.after after描述 */ this.fire( 'change', &#123; before: 'foo', after: 'bar' &#125; );&#125;; [建议] 对于类定义的模块，可以使用 @alias 标识构建函数。 示例： 1234567891011121314151617/** * A module representing a jacket. * @module jacket */define( function () &#123; /** * @class * @alias module:jacket */ var Jacket = function () &#123; &#125;; return Jacket; &#125;); [建议] 多模块定义时，可以使用 @exports 标识各个模块。 示例： 123456789101112131415161718192021222324// one moduledefine('html/utils', /** * Utility functions to ease working with DOM elements. * @exports html/utils */ function () &#123; var exports = &#123; &#125;; return exports; &#125;);// another moduledefine('tag', /** @exports tag */ function () &#123; var exports = &#123; &#125;; return exports; &#125;); [建议] 对于 exports 为 Object 的模块，可以使用@namespace标识。 解释： 使用 @namespace 而不是 @module 或 @exports 时，对模块的引用可以省略 module: 前缀。 [建议] 对于 exports 为类名的模块，使用 @class 和 @exports 标识。 示例： 12345678910111213141516171819202122// 只使用 @class Bar 时，类方法和属性都必须增加 @name Bar#methodName 来标识，与 @exports 配合可以免除这一麻烦，并且在引用时可以省去 module: 前缀。// 另外需要注意类名需要使用 var 定义的方式。/** * Bar description * * @see foo * @exports Bar * @class */var Bar = function () &#123; // TODO&#125;;/** * baz description * * @return &#123;(string|Array)&#125; return description */Bar.prototype.baz = function () &#123; // TODO&#125;; 2.4.13 细节注释 对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。 [建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。 示例： 1234567function foo(p1, p2, opt_p3) &#123; // 这里对具体内部逻辑进行说明 // 说明太长需要换行 for (...) &#123; .... &#125;&#125; [强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记： 解释： TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。 FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。 HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。 XXX: 该处存在陷阱。此时需要对陷阱进行描述。 3 语言特性 3.1 变量 [强制] 变量在使用前必须通过 var 定义。 解释： 不通过 var 定义变量将导致变量污染全局环境。 示例： 12345// goodvar name = 'MyName';// badname = 'MyName'; [强制] 每个 var 只能声明一个变量。 解释： 一个 var 声明多个变量，容易导致较长的行长度，并且在修改时容易造成逗号和分号的混淆。 示例： 123456789// goodvar hangModules = [];var missModules = [];var visited = &#123;&#125;;// badvar hangModules = [], missModules = [], visited = &#123;&#125;; [强制] 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。 解释： 变量声明与使用的距离越远，出现的跨度越大，代码的阅读与维护成本越高。虽然JavaScript的变量是函数作用域，还是应该根据编程中的意图，缩小变量出现的距离空间。 示例： 1234567891011121314151617181920212223242526272829303132333435// goodfunction kv2List(source) &#123; var list = []; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; var item = &#123; k: key, v: source[key] &#125;; list.push(item); &#125; &#125; return list;&#125;// badfunction kv2List(source) &#123; var list = []; var key; var item; for (key in source) &#123; if (source.hasOwnProperty(key)) &#123; item = &#123; k: key, v: source[key] &#125;; list.push(item); &#125; &#125; return list;&#125; 其中需要注意的几个 JS 变量声明提升 特性是： 变量声明会提升至作用域顶部，但赋值不会。 示例： 123456789101112131415161718// 我们知道这样不能正常工作（假设这里没有名为 notDefined 的全局变量）function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// 但由于变量声明提升的原因，在一个变量引用后再创建它的变量声明将可以正常工作。// 注：变量赋值为 `true` 不会提升。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 解释器会把变量声明提升到作用域顶部，意味着我们的例子将被重写成：function example() &#123; var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125; 匿名函数表达式会提升它们的变量名，但不会提升函数的赋值。 示例： 1234567function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () &#123; console.log('anonymous function expression'); &#125;;&#125; 命名函数表达式会提升变量名，但不会提升函数名或函数体。 示例： 12345678910111213141516171819function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// 当函数名跟变量名一样时，表现也是如此。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;&#125; 函数声明提升它们的名字和函数体。 示例： 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; [建议] 最后再声明未赋值的变量。 解释： 当需要引用前面的变量赋值时，这种做法将很有帮助。 示例： 123456789101112131415161718// badvar i, len, dragonball, items = getItems(), goSportsTeam = true;// badvar i;var items = getItems();var dragonball;var goSportsTeam = true;var len;// goodvar items = getItems();var goSportsTeam = true;var dragonball;var length;var i; 3.2 条件 [强制] 在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null。 解释： 使用 === 可以避免等于判断中隐式的类型转换。 示例： 123456789// goodif (age === 30) &#123; // ......&#125;// badif (age == 30) &#123; // ......&#125; [建议] 尽可能使用简洁的表达式。 示例： 1234567891011// 字符串为空// goodif (!name) &#123; // ......&#125;// badif (name === '') &#123; // ......&#125; 1234567891011// 字符串非空// goodif (name) &#123; // ......&#125;// badif (name !== '') &#123; // ......&#125; 1234567891011// 数组非空// goodif (collection.length) &#123; // ......&#125;// badif (collection.length &gt; 0) &#123; // ......&#125; 1234567891011// 布尔不成立// goodif (!notTrue) &#123; // ......&#125;// badif (notTrue === false) &#123; // ......&#125; 1234567891011// null 或 undefined// goodif (noValue == null) &#123; // ......&#125;// badif (noValue === null || typeof noValue === 'undefined') &#123; // ......&#125; 条件表达式，例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式，并且总是遵守下面的规则： 对象 被计算为 true ， 数组 或 函数 都属于 对象 undefined 被计算为 false null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0 、 -0 或 NaN 被计算为 fale ，否则为 true 字符串 如果是空字符串 '' 被计算为 false ，否则为 true [建议] 按执行频率排列分支的顺序。 解释： 按执行频率排列分支的顺序好处是： 阅读的人容易找到最常见的情况，增加可读性。 提高执行效率。 [建议] 对于相同变量或表达式的多值条件，用 switch 代替 if。 示例： 1234567891011121314151617181920// goodswitch (typeof variable) &#123; case 'object': // ...... break; case 'number': case 'boolean': case 'string': // ...... break;&#125;// badvar type = typeof variable;if (type === 'object') &#123; // ......&#125;else if (type === 'number' || type === 'boolean' || type === 'string') &#123; // ......&#125; [建议] 如果函数或全局中的 else 块后没有任何语句，可以删除 else。 示例： 123456789101112131415161718// goodfunction getName() &#123; if (name) &#123; return name; &#125; return 'unnamed';&#125;// badfunction getName() &#123; if (name) &#123; return name; &#125; else &#123; return 'unnamed'; &#125;&#125; 3.3 循环 [建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。 解释： 循环体中的函数表达式，运行过程中会生成循环次数个函数对象。 示例： 123456789101112131415// goodfunction clicker() &#123; // ......&#125;for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; addListener(element, 'click', clicker);&#125;// badfor (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; addListener(element, 'click', function () &#123;&#125;);&#125; [建议] 对循环内多次使用的不变值，在循环外用变量缓存。 示例： 1234567891011121314// goodvar width = wrap.offsetWidth + 'px';for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; element.style.width = width; // ......&#125;// badfor (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; element.style.width = wrap.offsetWidth + 'px'; // ......&#125; [建议] 对有序集合进行遍历时，缓存 length。 解释： 虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。 示例： 1234for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; // ......&#125; [建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。 解释： 逆序遍历可以节省变量，代码比较优化。 示例： 12345var len = elements.length;while (len--) &#123; var element = elements[len]; // ......&#125; 3.4 类型 3.4.1 类型检测 [建议] 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。 示例： 1234567891011121314151617181920212223242526272829// stringtypeof variable === 'string'// numbertypeof variable === 'number'// booleantypeof variable === 'boolean'// Functiontypeof variable === 'function'// Objecttypeof variable === 'object'// RegExpvariable instanceof RegExp// Arrayvariable instanceof Array// nullvariable === null// null or undefinedvariable == null// undefinedtypeof variable === 'undefined' 3.4.2 类型转换 [建议] 转换成 string 时，使用 + ''。 示例： 1234567// goodnum + '';// badnew String(num);num.toString();String(num); [建议] 转换成 number 时，通常使用 +。 示例： 12345// good+str;// badNumber(str); [建议] string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。 示例： 12var width = '200px';parseInt(width, 10); [强制] 使用 parseInt 时，必须指定进制。 示例： 12345// goodparseInt(str, 10);// badparseInt(str); [建议] 转换成 boolean 时，使用 !!。 示例： 12var num = 3.14;!!num; [建议] number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。 示例： 1234567// goodvar num = 3.14;Math.ceil(num);// badvar num = 3.14;parseInt(num, 10); 3.5 字符串 [强制] 字符串开头和结束使用单引号 '。 解释： 输入单引号不需要按住 shift，方便输入。 实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。 示例： 12var str = '我是一个字符串';var html = '&lt;div class="cls"&gt;拼接HTML可以省去双引号转义&lt;/div&gt;'; [建议] 使用 数组 或 + 拼接字符串。 解释： 使用 + 拼接字符串，如果拼接的全部是 StringLiteral，压缩工具可以对其进行自动合并的优化。所以，静态字符串建议使用 + 拼接。 在现代浏览器下，使用 + 拼接字符串，性能较数组的方式要高。 如需要兼顾老旧浏览器，应尽量使用数组拼接字符串。 示例： 123456789101112131415// 使用数组拼接字符串var str = [ // 推荐换行开始并缩进开始第一个字符串, 对齐代码, 方便阅读. '&lt;ul&gt;', '&lt;li&gt;第一项&lt;/li&gt;', '&lt;li&gt;第二项&lt;/li&gt;', '&lt;/ul&gt;'].join('');// 使用 + 拼接字符串var str2 = '' // 建议第一个为空字符串, 第二个换行开始并缩进开始, 对齐代码, 方便阅读 + '&lt;ul&gt;', + '&lt;li&gt;第一项&lt;/li&gt;', + '&lt;li&gt;第二项&lt;/li&gt;', + '&lt;/ul&gt;'; [建议] 复杂的数据到视图字符串的转换过程，选用一种模板引擎。 解释： 使用模板引擎有如下好处： 在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。 优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。 artTemplate: 体积较小，在所有环境下性能高，语法灵活。 dot.js: 体积小，在现代浏览器下性能高，语法灵活。 etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。 handlebars: 体积大，在所有环境下性能高，扩展性高。 hogon: 体积小，在现代浏览器下性能高。 nunjucks: 体积较大，性能一般，模板复用性高。 3.6 对象 [强制] 使用对象字面量 {} 创建新 Object。 示例： 12345// goodvar obj = &#123;&#125;;// badvar obj = new Object(); [强制] 对象创建时，如果一个对象的所有 属性 均可以不添加引号，则所有 属性 不得添加引号。 示例： 1234var info = &#123; name: 'someone', age: 28&#125;; [强制] 对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 必须添加 '。 解释： 如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。 示例： 12345678910111213// goodvar info = &#123; 'name': 'someone', 'age': 28, 'more-info': '...'&#125;;// badvar info = &#123; name: 'someone', age: 28, 'more-info': '...'&#125;; [强制] 不允许修改和扩展任何原生对象和宿主对象的原型。 示例： 123// 以下行为绝对禁止String.prototype.trim = function () &#123;&#125;; [建议] 属性访问时，尽量使用 .，当通过变量访问属性时使用 [expr]。 解释： 属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。 通常在 JavaScript 中声明的对象，属性命名是使用 Camel 命名法，用 . 来访问更清晰简洁。部分特殊的属性(比如来自后端的JSON)，可能采用不寻常的命名方式，可以通过 [expr] 方式访问。 示例： 12345678910111213info.age;info['more-info'];var stu = &#123; status: true, age: 13&#125;;function getProp(prop) &#123; return stu[prop];&#125;var isStatusOk = getProp('status'); [建议] for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。 示例： 123456var newInfo = &#123;&#125;;for (var key in info) &#123; if (info.hasOwnProperty(key)) &#123; newInfo[key] = info[key]; &#125;&#125; [强制] 不要使用 保留字 作为键名，它们在 IE8下不工作。 示例： 1234567891011// badvar superman = &#123; default: &#123; clark: 'kent' &#125;, private: true&#125;;// goodvar superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true&#125;; [建议] 使用同义词替换需要使用的保留字 示例： 1234567891011121314// badvar superman = &#123; class: 'alien'&#125;;// badvar superman = &#123; klass: 'alien'&#125;;// goodvar superman = &#123; type: 'alien'&#125;; 3.7 数组 [强制] 使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。 示例： 12345// goodvar arr = [];// badvar arr = new Array(); [强制] 遍历数组不使用 for in。 解释： 数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果. 示例： 123456789101112var arr = ['a', 'b', 'c'];arr.other = 'other things'; // 这里仅作演示, 实际中应使用Object类型// 正确的遍历方式for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(i);&#125;// 错误的遍历方式for (i in arr) &#123; console.log(i);&#125; [建议] 不因为性能的原因自己实现数组排序功能，尽量使用数组的 sort 方法。 解释： 自己实现的常规排序算法，在性能上并不优于数组默认的 sort 方法。以下两种场景可以自己实现排序： 需要稳定的排序算法，达到严格一致的排序结果。 数据特点鲜明，适合使用桶排。 [建议] 清空数组使用 .length = 0。 [建议] 向数组增加元素时使用 Array#push 来替代直接赋值 示例： 1234567var someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); [建议] 当需要拷贝数组时，使用 Array#slice 。 示例： 1234567891011var len = items.length;var itemsCopy = [];var i;// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// gooditemsCopy = items.slice(); 3.8 函数 [强制] 禁止在一个 非函数代码块（if、while等） 中声明一个函数，如果需要，则把函数赋值给一个变量。 解释： 浏览器允许这么操作，但不同厂商产品之间的解析存在不一致。 示例： 1234567891011121314// badif (currentUser) &#123; function testFun() &#123; console.log('Nope.'); &#125;&#125;// goodvar test;if (currentUser) &#123; test = function testFun() &#123; console.log('Yup.'); &#125;;&#125; 3.8.1 函数表达式 解释： 分3种写法，匿名、命名以及立即执行函数表达式。 示例： 1234567891011121314// 匿名函数表达式var anonymous = function() &#123; return true;&#125;;// 命名函数表达式var named = function named() &#123; return true;&#125;;// 立即调用的函数表达式（IIFE）(function () &#123; console.log('Welcome to the Internet. Please follow me.');&#125;()); 3.8.2 函数长度 [建议] 一个函数的长度控制在 50 行以内。 解释： 将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。 特定算法等不可分割的逻辑允许例外。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function syncViewStateOnUserAction() &#123; if (x.checked) &#123; y.checked = true; z.value = ''; &#125; else &#123; y.checked = false; &#125; if (!a.value) &#123; warning.innerText = 'Please enter it'; submitButton.disabled = true; &#125; else &#123; warning.innerText = ''; submitButton.disabled = false; &#125;&#125;// 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：function syncViewStateOnUserAction() &#123; syncXStateToView(); checkAAvailability();&#125;function syncXStateToView() &#123; if (x.checked) &#123; y.checked = true; z.value = ''; &#125; else &#123; y.checked = false; &#125;&#125;function checkAAvailability() &#123; if (!a.value) &#123; displayWarningForAMissing(); &#125; else &#123; clearWarnignForA(); &#125;&#125; 3.8.3 参数设计 [建议] 一个函数的参数控制在 6 个以内。 解释： 除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。 某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。 [建议] 通过 options 参数传递非数据输入型参数。 解释： 有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。 如下函数： 123456789101112/** * 移除某个元素 * * @param &#123;Node&#125; element 需要移除的元素 * @param &#123;boolean&#125; removeEventListeners 是否同时将所有注册在元素上的事件移除 */function removeElement(element, removeEventListeners) &#123; element.parent.removeChild(element); if (removeEventListeners) &#123; element.clearEventListeners(); &#125;&#125; 可以转换为下面的签名： 12345678910111213/** * 移除某个元素 * * @param &#123;Node&#125; element 需要移除的元素 * @param &#123;Object&#125; options 相关的逻辑配置 * @param &#123;boolean&#125; options.removeEventListeners 是否同时将所有注册在元素上的事件移除 */function removeElement(element, options) &#123; element.parent.removeChild(element); if (options.removeEventListeners) &#123; element.clearEventListeners(); &#125;&#125; 这种模式有几个显著的优势： boolean 型的配置项具备名称，从调用的代码上更易理解其表达的逻辑意义。 当配置项有增长时，无需无休止地增加参数个数，不会出现 removeElement(element, true, false, false, 3) 这样难以理解的调用代码。 当部分配置参数可选时，多个参数的形式非常难处理重载逻辑，而使用一个 options 对象只需判断属性是否存在，实现得以简化。 [强制] 禁止将参数命名为 arguments 。 解释： 如此命名，会将函数作用域内的 arguments 对象取代。 示例： 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; 3.8.4 闭包 [建议] 在适当的时候将闭包内大对象置为 null。 解释： 在 JavaScript 中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用域外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。 闭包会阻止一些变量的垃圾回收，对于较老旧的JavaScript引擎，可能导致外部所有变量均无法回收。 首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收： 嵌套的函数中是否有使用该变量。 嵌套的函数中是否有 直接调用eval。 是否使用了 with 表达式。 Chakra、V8 和 SpiderMonkey 将受以上因素的影响，表现出不尽相同又较为相似的回收策略，而JScript.dll和Carakan则完全没有这方面的优化，会完整保留整个 LexicalEnvironment 中的所有变量绑定，造成一定的内存消耗。 由于对闭包内变量有回收优化策略的 Chakra、V8 和 SpiderMonkey 引擎的行为较为相似，因此可以总结如下，当返回一个函数 fn 时： 如果 fn 的 [[Scope]] 是ObjectEnvironment（with 表达式生成 ObjectEnvironment，函数和 catch 表达式生成 DeclarativeEnvironment），则： 如果是 V8 引擎，则退出全过程。 如果是 SpiderMonkey，则处理该 ObjectEnvironment 的外层 LexicalEnvironment。 获取当前 LexicalEnvironment 下的所有类型为 Function 的对象，对于每一个 Function 对象，分析其 FunctionBody： 如果 FunctionBody 中含有 直接调用eval，则退出全过程。 否则得到所有的 Identifier。 对于每一个 Identifier，设其为 name，根据查找变量引用的规则，从 LexicalEnvironment 中找出名称为 name 的绑定 binding。 对 binding 添加 notSwap 属性，其值为 true。 检查当前 LexicalEnvironment 中的每一个变量绑定，如果该绑定有 notSwap 属性且值为 true，则： 如果是V8引擎，删除该绑定。 如果是SpiderMonkey，将该绑定的值设为 undefined，将删除 notSwap 属性。 对于Chakra引擎，暂无法得知是按 V8 的模式还是按 SpiderMonkey 的模式进行。 如果有 非常庞大 的对象，且预计会在 老旧的引擎 中执行，则使用闭包时，注意将闭包不需要的对象置为空引用。 [建议] 使用 IIFE 避免 Lift 效应。 解释： 在引用函数外部变量时，函数执行时外部变量的值由运行时决定而非定义时，最典型的场景如下： 1234567891011var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; tasks[tasks.length] = function () &#123; console.log('Current cursor is at ' + i); &#125;;&#125;var len = tasks.length;while (len--) &#123; tasks[len]();&#125; 以上代码对 tasks 中的函数的执行均会输出 Current cursor is at 5，往往不符合预期。 此现象称为 Lift 效应 。解决的方式是通过额外加上一层闭包函数，将需要的外部变量作为参数传递来解除变量的绑定关系： 1234567891011121314var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; // 注意有一层额外的闭包 tasks[tasks.length] = (function (i) &#123; return function () &#123; console.log('Current cursor is at ' + i); &#125;; &#125;)(i);&#125;var len = tasks.length;while (len--) &#123; tasks[len]();&#125; 3.8.5 空函数 [建议] 空函数不使用 new Function() 的形式。 示例： 1var emptyFunction = function () &#123;&#125;; [建议] 对于性能有高要求的场合，建议存在一个空函数的常量，供多处使用共享。 示例： 12345678var EMPTY_FUNCTION = function () &#123;&#125;;function MyClass() &#123;&#125;MyClass.prototype.abstractMethod = EMPTY_FUNCTION;MyClass.prototype.hooks.before = EMPTY_FUNCTION;MyClass.prototype.hooks.after = EMPTY_FUNCTION; 3.9 面向对象 [强制] 类的继承方案，实现时需要修正 constructor。 解释： 通常使用其他 library 的类继承方案都会进行 constructor 修正。如果是自己实现的类继承方案，需要进行 constructor 修正。 示例： 123456789101112/** * 构建类之间的继承关系 * * @param &#123;Function&#125; subClass 子类函数 * @param &#123;Function&#125; superClass 父类函数 */function inherits(subClass, superClass) &#123; var F = new Function(); F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass;&#125; [建议] 声明类时，保证 constructor 的正确性。 示例： 1234567891011121314151617function Animal(name) &#123; this.name = name;&#125;// 直接prototype等于对象时，需要修正constructorAnimal.prototype = &#123; constructor: Animal, jump: function () &#123; alert('animal ' + this.name + ' jump'); &#125;&#125;;// 这种方式扩展prototype则无需理会constructorAnimal.prototype.jump = function () &#123; alert('animal ' + this.name + ' jump');&#125;; [建议] 属性在构造函数中声明，方法在原型中声明。 解释： 原型对象的成员被所有实例共享，能节约内存占用。所以编码时我们应该遵守这样的原则：原型对象包含程序不会修改的成员，如方法函数或配置项。 12345678function TextNode(value, engine) &#123; this.value = value; this.engine = engine;&#125;TextNode.prototype.clone = function () &#123; return this;&#125;; [强制] 给对象原型分配方法，而不是使用一个新对象覆盖原型。 解释： 覆盖原型将导致继承出现问题：重设原型将覆盖原有原型。 示例： 1234567891011121314151617181920212223function Jedi() &#123; console.log('new jedi');&#125;// badJedi.prototype = &#123; fight: function fight() &#123; console.log('fighting'); &#125;, block: function block() &#123; console.log('blocking'); &#125;&#125;;// goodJedi.prototype.fight = function fight() &#123; console.log('fighting');&#125;;Jedi.prototype.block = function block() &#123; console.log('blocking');&#125;; [建议] 方法可以返回 this 来实现方法链式操作。 示例： 12345678910111213141516171819202122232425262728// badJedi.prototype.jump = function jump() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height;&#125;;var luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodJedi.prototype.jump = function jump() &#123; this.jumping = true; return this;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height; return this;&#125;;var luke = new Jedi();luke.jump().setHeight(20); [建议] 可以自定义 toString() 方法，但确保其可以正常工作且不会产生副作用。 示例： 123456789101112function Jedi(options) &#123; options || (options = &#123;&#125;); this.name = options.name || 'no name';&#125;Jedi.prototype.getName = function getName() &#123; return this.name;&#125;;Jedi.prototype.toString = function toString() &#123; return 'Jedi - ' + this.getName();&#125;; [强制] 自定义事件的 事件名 必须全小写。 解释： 在 JavaScript 广泛应用的浏览器环境，绝大多数 DOM 事件名称都是全小写的。为了遵循大多数 JavaScript 开发者的习惯，在设计自定义事件时，事件名也应该全小写。 [强制] 自定义事件只能有一个 event 参数。如果事件需要传递较多信息，应仔细设计事件对象。 解释： 一个事件对象的好处有： 顺序无关，避免事件监听者需要记忆参数顺序。 每个事件信息都可以根据需要提供或者不提供，更自由。 扩展方便，未来添加事件信息时，无需考虑会破坏监听器参数形式而无法向后兼容。 [建议] 设计自定义事件时，应考虑禁止默认行为。 解释： 常见禁止默认行为的方式有两种： 事件监听函数中 return false。 事件对象中包含禁止默认行为的方法，如 preventDefault。 3.10 动态特性 3.10.1 eval [强制] 避免使用直接 eval 函数。 解释： 直接 eval，指的是以函数方式调用 eval 的调用方法。直接 eval 调用执行代码的作用域为本地作用域，应当避免。 如果有特殊情况需要使用直接 eval，需在代码中用详细的注释说明为何必须使用直接 eval，不能使用其它动态执行代码的方式，同时需要其他资深工程师进行 Code Review。 [建议] 尽量避免使用 eval 函数。 3.10.2 动态执行代码 [建议] 使用 new Function 执行动态代码。 解释： 通过 new Function 生成的函数作用域是全局使用域，不会影响当当前的本地作用域。如果有动态代码执行的需求，建议使用 new Function。 示例： 12var handler = new Function('x', 'y', 'return x + y;');var result = handler($('#x').val(), $('#y').val()); 3.10.3 with [建议] 尽量不要使用 with。 解释： 使用 with 可能会增加代码的复杂度，不利于阅读和管理；也会对性能有影响。大多数使用 with 的场景都能使用其他方式较好的替代。所以，尽量不要使用 with。 3.10.4 delete [建议] 减少 delete 的使用。 解释： 如果没有特别的需求，减少或避免使用delete。delete的使用会破坏部分 JavaScript 引擎的性能优化。 [建议] 处理 delete 可能产生的异常。 解释： 对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。 在严格模式或IE下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。 示例： 123456try &#123; delete o.x;&#125;catch (deleteError) &#123; o.x = null;&#125; 3.10.5 对象属性 [建议] 避免修改外部传入的对象。 解释： JavaScript 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。 但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题。因此，设计良好的组件、函数应该避免对外部传入的对象的修改。 下面代码的 selectNode 方法修改了由外部传入的 datasource 对象。如果 datasource 用在其它场合（如另一个 Tree 实例）下，会造成状态的混乱。 123456789101112function Tree(datasource) &#123; this.datasource = datasource;&#125;Tree.prototype.selectNode = function (id) &#123; // 从datasource中找出节点对象 var node = this.findNode(id); if (node) &#123; node.selected = true; this.flushView(); &#125;&#125;; 对于此类场景，需要使用额外的对象来维护，使用由自身控制，不与外部产生任何交互的 selectedNodeIndex 对象来维护节点的选中状态，不对 datasource 作任何修改。 12345678910111213function Tree(datasource) &#123; this.datasource = datasource; this.selectedNodeIndex = &#123;&#125;;&#125;Tree.prototype.selectNode = function (id) &#123; // 从datasource中找出节点对象 var node = this.findNode(id); if (node) &#123; this.selectedNodeIndex[id] = true; this.flushView(); &#125;&#125;; 除此之外，也可以通过 deepClone 等手段将自身维护的对象与外部传入的分离，保证不会相互影响。 [建议] 具备强类型的设计。 解释： 如果一个属性被设计为 boolean 类型，则不要使用 1 / 0 作为其值。对于标识性的属性，如对代码体积有严格要求，可以从一开始就设计为 number 类型且将 0 作为否定值。 从 DOM 中取出的值通常为 string 类型，如果有对象或函数的接收类型为 number 类型，提前作好转换，而不是期望对象、函数可以处理多类型的值。 3.11 存取器 [建议] 属性的存取函数不是必须的。 [建议] 如需要存取函数，使用 getVal() 和 setVal() 。 示例： 1234567891011// baddragon.age();// gooddragon.getAge();// baddragon.age(25);// gooddragon.setAge(25); [建议] 如属性是布尔值 ，使用 isVal() 和 hasVal() 。 示例： 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; [建议] 创建 get() 和 set() 函数是可以的，但要保持一致。 示例： 12345678910111213function Jedi(options) &#123; options || (options = &#123;&#125;); var lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber);&#125;Jedi.prototype.set = function set(key, val) &#123; this[key] = val;&#125;;Jedi.prototype.get = function get(key) &#123; return this[key];&#125;; 4 浏览器环境 4.1 模块化 4.1.1 AMD [强制] 使用 AMD 作为模块定义。 解释： AMD 作为由社区认可的模块定义形式，提供多种重载提供灵活的使用方式，并且绝大多数优秀的 Library 都支持 AMD，适合作为规范。 目前，比较成熟的 AMD Loader 有： 官方实现的 requirejs 百度实现的 esl [强制] 模块 id 必须符合标准。 解释： 模块 id 必须符合以下约束条件： 类型为 string，并且是由 / 分割的一系列 terms 来组成。例如：this/is/a/module。 term 应该符合 [a-zA-Z0-9_-]+ 规则。 不应该有 .js 后缀。 跟文件的路径保持一致。 4.1.2 define [建议] 定义模块时不要指明 id 和 dependencies。 解释： 在 AMD 的设计思想里，模块名称是和所在路径相关的，匿名的模块更利于封包和迁移。模块依赖应在模块定义内部通过 local require 引用。 所以，推荐使用 define(factory) 的形式进行模块定义。 示例： 1234define( function (require) &#123; &#125;); [建议] 使用 return 来返回模块定义。 解释： 使用 return 可以减少 factory 接收的参数（不需要接收 exports 和 module），在没有 AMD Loader 的场景下也更容易进行简单的处理来伪造一个 Loader。 示例： 123456789define( function (require) &#123; var exports = &#123;&#125;; // ... return exports; &#125;); 4.1.3 require [强制] 全局运行环境中，require 必须以 async require 形式调用。 解释： 模块的加载过程是异步的，同步调用并无法保证得到正确的结果。 示例： 123456// goodrequire(['foo'], function (foo) &#123;&#125;);// badvar foo = require('foo'); [强制] 模块定义中只允许使用 local require，不允许使用 global require。 解释： 在模块定义中使用 global require，对封装性是一种破坏。 在 AMD 里，global require 是可以被重命名的。并且 Loader 甚至没有全局的 require 变量，而是用 Loader 名称做为 global require。模块定义不应该依赖使用的 Loader。 [强制] Package在实现时，内部模块的 require 必须使用 relative id。 解释： 对于任何可能通过 发布-引入 的形式复用的第三方库、框架、包，开发者所定义的名称不代表使用者使用的名称。因此不要基于任何名称的假设。在实现源码中，require 自身的其它模块时使用 relative id。 示例： 12345define( function (require) &#123; var util = require('./util'); &#125;); [建议] 不会被调用的依赖模块，在 factory 开始处统一 require。 解释： 有些模块是依赖的模块，但不会在模块实现中被直接调用，最为典型的是 css / js / tpl 等 Plugin 所引入的外部内容。此类内容建议放在模块定义最开始处统一引用。 示例： 12345678define( function (require) &#123; require('css!foo.css'); require('tpl!bar.tpl.html'); // ... &#125;); 4.2 DOM 4.2.1 元素获取 [建议] 对于单个元素，尽可能使用 document.getElementById 获取，避免使用 document.all 。 [建议] 对于多个元素的集合，尽可能使用 context.getElementsByTagName 获取。其中 context 可以为 document 或其他元素。指定 tagName 参数为 * 可以获得所有子元素。 [建议] 遍历元素集合时，尽量缓存集合长度。如需多次操作同一集合，则应将集合转为数组。 解释： 原生获取元素集合的结果并不直接引用 DOM 元素，而是对索引进行读取，所以 DOM 结构的改变会实时反映到结果中。 示例： 12345678910111213141516&lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;&lt;script&gt;var elements = document.getElementsByTagName('*');// 显示为 DIValert(elements[0].tagName);var div = elements[0];var p = document.createElement('p');document.body.insertBefore(p, div);// 显示为 Palert(elements[0].tagName);&lt;/script&gt; [建议] 获取元素的直接子元素时使用 children。避免使用 childNodes ，除非预期是需要包含文本、注释和属性类型的节点。 4.2.2 样式获取 [建议] 获取元素实际样式信息时，应使用 getComputedStyle 或 currentStyle 。 解释： 通过 style 只能获得内联定义或通过 JavaScript 直接设置的样式。通过 CSS class 设置的元素样式无法直接通过 style 获取。 4.2.3 样式设置 [建议] 尽可能通过为元素添加预定义的 className 来改变元素样式，避免直接操作 style 设置。 [强制] 通过 style 对象设置元素样式时，对于带单位非 0 值的属性，不允许省略单位。 解释： 除了 IE，标准浏览器会忽略不规范的属性值，导致兼容性问题。 4.2.4 DOM 操作 [建议] 操作 DOM 时，尽量减少页面 reflow。 解释： 页面 reflow 是非常耗时的行为，非常容易导致性能瓶颈。下面一些场景会触发浏览器的reflow： DOM元素的添加、修改（内容）、删除。 应用新的样式或者修改任何影响元素布局的属性。 Resize浏览器窗口、滚动页面。 读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 。 [建议] 尽量减少 DOM 操作。 解释： DOM 操作也是非常耗时的一种操作，减少 DOM 操作有助于提高性能。举一个简单的例子，构建一个列表。我们可以用两种方式： 在循环体中 createElement 并 append 到父元素中。 在循环体中拼接 HTML 字符串，循环结束后写父元素的 innerHTML。 第一种方法看起来比较标准，但是每次循环都会对 DOM 进行操作，性能极低。在这里推荐使用第二种方法。 4.2.5 DOM 事件 [建议] 优先使用 addEventListener / attachEvent 绑定事件，避免直接在 HTML 属性中或 DOM 的 expando 属性绑定事件处理。 解释： expando 属性绑定事件容易导致互相覆盖。 [建议] 使用 addEventListener 时第三个参数使用 false。 解释： 标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。 [建议] 在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。 5 jQuery 5.1 jQuery 变量 [强制] 所有使用或缓存 jQuery 对象的变量应该以 $ 开头。 示例： 12345// badvar sidebar = $('.sidebar');// goodvar $sidebar = $('.sidebar'); [建议] 将 jQuery 选择器返回的对象缓存到本地变量中以复用。 解释： 选中某一个页面元素，开销很大。所以，使用选择器的次数应该越少越好，对于多次需要操作的元素，尽可能缓存选中的结果，节省其开销。 示例： 1234567891011121314151617181920// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; 5.2 选择器 选择器的性能排序： 最快的选择器：ID 选择器和元素标签选择器 举例来说，下面的语句性能最佳： 123$("#id");$("form");$("input"); 因为遇到这些选择器，jQuery 内部会自动调用浏览器原生方法，所以执行速度快。 较慢的选择器：class 选择器 $(&quot;.className&quot;) 的性能，取决于不同的浏览器。Chrome、Firefox、Safari、Opera 浏览器，都有原生方法 getElementByClassName() ，所以速度并不慢。但是，IE5-IE8 都没有部署这个方法，所以这个选择器在 IE 中会相当慢，jQuery 历次更新对 IE8 之前的版本来说是没有用处的。 最慢的选择器：伪类选择器和属性选择器 如 $(&quot;:hidden&quot;) ，找出网页中所有隐藏元素；属性选择器例子 $(&quot;[attribute=value]&quot;) 。这两种语句是最慢的，因为浏览器没有针对它们的原生方法。但一些浏览器的新版本，增加了 querySelector() 和 querySelectorAll() 方法，因此会使这类选择器的性能大幅提高。 子元素和父元素关系： 常见子、父元素写法： 123456$('.child', $parent);$parent.find('.child');$parent.children('.child');$('#parent &gt; .child');$('#parent .child');$('.child', $('#parent')); 以上几种写法，其速度比较： $('.child', $parent) 作用是：给定一个 DOM 对象，然后从中选择一个子元素。jQuery 会自动把这条语句转成 $.parent.find('.child') ，这会导致一定的性能损失，比最快方案慢 5%~10% 。 $parent.find('.child') 这是一种最优方案。 find() 方法会调用浏览器的原生方法（getElementById，getElementByName，getElementByTagName 等），因此速度最优。 $parent.children('.child') jQuery 内部会使用 $.sibling() 和 javascript 的 nextSibling() 方法，一个个遍历节点，比最快方案慢 50% 。 $('#parent &gt; .child') jQuery 内部使用 Sizzle 引擎，处理各种选择器。Sizzle 引擎的选择顺序是从右到左，所以这条语句是先选 .chile ，然后再一个个过滤出父元素 #parent ，因此，该写法相比最快方案慢 70% 。 $('#parent .child') 本条与上一条情况相同，但是，上一条只选择直接的子元素，这里可以用于选择多级子元素，所以速度更慢，相比最快方案慢 77% 。 $('.child', $('#parent')) jQuery 内部会将其转换为 $('#parent').find('.child') ，比最快方案慢 20% 。 因此，几种不同写法中，最佳选择是：$parent.find('.child') 。 [建议] ID 选择器可用时，使用 ID 选择。 解释： 在 jQuery 内部，使用 document.getElementById() 。 [建议] 使用类/伪类选择器时，给选择器附上元素类型来避免扫描整个 DOM 树。 示例： 1234567// bad// 在整个DOM树中扫描"products"类名var $products = $(".products");// good// 只在DIV元素中扫描"products"类名var $products = $("div.products"); [建议] 在 ID &gt; 子节点 层级选择器中使用 find() 方法。 解释： 因为前半部分选择器没使用到 Sizzle 选择器引擎来查找元素。 示例： 1234567// bad// Sizzle 选择器引擎查找层级var $productIds = $("#products div.id");// good// 只有 div.id 走 Sizzle 选择器引擎var $productIds = $("#products").find("div.id"); [建议] 选择器后半部分比前半部分明确。 示例： 1234567// bad// 未优化$("div.data .gonzalez");// good// 优化$(".data td.gonzalez"); [建议] 避免冗余选择器。 示例： 123456// bad$(".data table.attendees td.gonzalez");// good// 有必要时要去掉中间不必要的内容$(".data td.gonzalez"); [建议] 给选择器添加上下文。 示例： 123456789// bad// 要扫描整个DOM树寻找$('.class');// good// 只在#class-container里扫描$('.class', '#class-container');// 更为高效的写法$('#class-container').find('.class'); [强制] 禁止使用通配符选择器。 示例： 12345// bad$('div.container &gt; *');// good$('div.container').children(); [强制] 禁止使用隐式通配选择器。 解释： 采用隐式通配选择器时，会隐式的使用通配符选择器。 示例： 12345// bad$('div.someclass :radio');// good$('div.someclass input:radio'); [强制] ID 选择器禁止嵌套。 示例： 1234567// bad$('#outer #inner');$('div#inner');$('.outer-container #inner');// good$('#inner'); 5.3 DOM 操作 [建议] 始终先 detach 现有 DOM 元素后进行操作，再将其 append DOM 中。 解释： detach 提取出元素后，我们可以在这个元素上进行相关操作，而不是在整个 DOM 文档中进行操作。这样可以减少对整个 DOM 文档的修改，从而减少页面重绘。 示例： 123456789101112//事件代理$('#container').on('click',function(event) &#123; console.log($(event.target).text());&#125;);//利用detach将container从dom文档中剥离开var $container = $('#container').detach();var child1 = '&lt;div&gt;I am Monkey&lt;/div&gt;';var child2 = '&lt;div&gt;Monkey is me&lt;/div&gt;';//将child1、child2插入container中$($container).append(child1).append(child2);//将container重新插入body中$('body').append($container); [建议] 使用字符串连接 + 或者 array.join() ，而不是 .append() 方法。 示例： 1234567891011121314151617181920// badvar $myList = $("#list");for (var i = 0; i &lt; 10000; i++) &#123; $myList.append("&lt;li&gt;"+i+"&lt;/li&gt;");&#125;// goodvar $myList = $("#list");var list = "";for (var i = 0; i &lt; 10000; i++) &#123; list += "&lt;li&gt;"+i+"&lt;/li&gt;";&#125;$myList.html(list);// bettervar array = [];for (var i = 0; i &lt; 10000; i++) &#123; array[i] = "&lt;li&gt;"+i+"&lt;/li&gt;";&#125;$myList.html(array.join('')); [建议] 不操作未知元素。 示例： 123456789// bad// 这个函数内部要先执行3个函数，才发现选择器选择到的可能是空内容$("#nosuchthing").slideUp();// goodvar $mySelection = $("#nosuchthing");if ($ Selection.length) &#123; $mySelection.slideUp();&#125; [建议] 尽量少生成 jQuery 对象。 解释： 每当你使用一次选择器（如：$('#id')），就会生成一个 jQuery 对象。jQuery 对象是一个很庞大的对象，带有很多的属性和方法，会占用不少的资源。所以，尽量少生成 jQuery 对象。 许多 jQuery 方法都有两个版本： 供 jQuery 对象使用的版本 供 jQuery 函数使用的版本 由于后一种针对 jQuery 函数的版本不通过 jQuery 对象操作，所以相对开销较小，速度比较快。 示例： 123456789101112131415// badvar $text = $("#text");var str = $text.text();// goodvar $text = $("#text");var str = $.text($text);//badvar $elem = $('#elem');$elem.data(key, value);// goodvar $elem = $('#elem');$.data($elem, key, value); [建议] 优先采用原生写法实现循环。 解释： 循环是一种比较耗时的操作，javascript 原生循环方法 for 和 while ，要比 jQuery 的 .each() 方法快，所以优先采用原生方法。 [建议] 参数尽量使用对象字面量。 示例： 123456789// bad$myLink.attr("href", "#").attr("title", "my link").attr("rel", "external");// good$myList.attr(&#123; href: "#", title: "my link", rel: "external"&#125;); [建议] 不要把 CSS 混入 jQuery 代码。 示例： 123456// bad$("#mydiv").css(&#123;'color':red, 'font-weight':'bold'&#125;);// good.error &#123; color: red; font-weight: bold; &#125;$("#mydiv").addClass("error"); 5.4 事件 [强制] 每个页面只使用一个 Document Ready 函数，便于调试。 [建议] 不使用匿名函数绑定事件。 解释： 匿名函数不利于调试、维护、测试和复用。 示例： 1234567891011// bad$("#myLink").on('click', function() &#123; // ...&#125;);// goodfunction myLinkClickHandler() &#123; // ...&#125;$("#myLink").on("click", myLinkClickHandler); [建议] Document Ready 函数不使用匿名函数。 示例： 1234567891011121314// bad// 不易复用和测试$(function() &#123; // ...&#125;);// good$(initPage);// or$(document).ready(initPage);function initPage() &#123; // ...&#125; [建议] Document Ready 函数写在外部函数里，在其他初始化设置之后，在行内 JS 里调用这些函数。 示例： 123456&lt;script src="my-document-ready.js"&gt;&lt;/script&gt;&lt;script&gt; // 任何其他需要设置的全局变量 $(document).ready(initPage); // or $(initPage);&lt;/script&gt; [强制] 不在 HTML 文件里添加行内 JS 。 示例： 1234567&lt;!-- bad --&gt;&lt;a id="myLink" href="#" onclick="myEventHandler();"&gt;my link&lt;/a&gt;&lt;!-- good --&gt;&lt;script&gt; $("#myLink").on("click", myEventHandler);&lt;/script&gt; [建议] 在特定情况下，对事件使用自定义命名空间。 解释： 有利于解绑某 DOM 元素上特定的事件而不会影响到该 DOM 元素上其他的事件。 示例： 123$("#myLink").on("click.mySpecialClick", myEventHandler);// 后面会很容易的解绑这个特定的点击事件$("#myLink").unbind("click.mySpecialClick"); [建议] 采用事件的委托处理。 解释： javascript 的事件模型，采用”冒泡”模式，也就是说，子元素的事件会逐级向上”冒泡”，成为父元素的事件。 利用这一点，可以大大简化事件的绑定。比如，有一个表格（ table 元素），里面有100个格子（ td 元素），现在要求在每个格子上面绑定一个点击事件（ click ），请问是否需要将下面的命令执行100次？ 回答是不需要，我们只要把这个事件绑定在 table 元素上面就可以了，因为 td 元素发生点击事件之后，这个事件会”冒泡”到父元素 table 上面，从而被监听到。 因此，这个事件只需要在父元素绑定1次即可，而不需要在子元素上绑定100次，从而大大提高性能。这就叫事件的”委托处理”，也就是子元素”委托”父元素处理这个事件。 具体的写法有两种。 采用 .delegate() 方法 采用 .live() 方法 示例： 12345678910111213141516// bad$("td").bind("click", function() &#123; $(this).toggleClass("click");&#125;);// good// fun 1$("table").delegate("td", "click", function() &#123; $(this).toggleClass("click");&#125;);// fun 2$("table").each(function() &#123; $("td", this).live("click", function() &#123; $(this).toggleClass("click"); &#125;);&#125;); 这两种写法基本等价。唯一的区别在于， .delegate() 是当事件冒泡到指定的父元素时触发， .live() 则是当事件冒泡到文档的根元素后触发，因此 .delegate() 比 .live() 稍快一点。此外，这两种方法相比传统的 .bind() 方法还有一个好处，那就是对动态插入的元素也有效， .bind() 只对已经存在的DOM元素有效，对动态插入的元素无效。 根据测试，委托处理比不委托处理，快了几十倍。在委托处理的情况下， .delegate() 又比 .live() 大约快26%。 5.5 Ajax [建议] 直接使用 $.ajax() ,避免使用 .getJSON() 和 .get() 。 解释： .getJSON() 和 .get() 都是在内部调用 $.ajax() 实现。 [建议] 不要在 https 的站点使用 http 请求，采用无模式的 url （在 url 上去掉 http/https）。 [强制] 禁止请求参数放在 url 里，而是放在 data 对象。 示例： 12345678910111213141516// bad// 不可读$.ajax(&#123; url: "something.php?param1=test1&amp;param2=test2", //....&#125;);// good// 可读$.ajax(&#123; url: "something.php", data: &#123; param1: test1, param2: test2 &#125;&#125;); [建议] 明确设置数据的类型 dataType 据。 解释： 这样很容易知道当前正在处理什么样的数。 [建议] 对 Ajax 加载的 DOM 元素绑定事件时尽量使用事件代理。 解释： 事件代理的优势是对于 Ajax 后来添加到 DOM 的元素也能响应事件。 示例： 1$("#parent-container").on("click", "a", delegatedClickHandlerForAjax); [建议] 使用 Promise 。 示例： 12345678910111213$.ajax(&#123; // ...&#125;).then( successHandler, failureHandler);// orvar jqxhr = $.ajax(&#123; // ...&#125;);jqxhr.done(successHandler);jqxhr.fail(failureHandler); [建议] Ajax 参考模板。 示例： 1234567891011121314var jqxhr = $.ajax(&#123; url: url, type: "GET", // 默认值GET，可根据需要配置 cache: true, // 默认值true, dataType是'script'或'jsonp'时为false，可根据需要配置 data: &#123;&#125;, // 请求参数对象 dataType: "json", // 设置数据类型 jsonp: "callback",// 只在操作JSONP时设置此项 statusCode: &#123; // 针对特定错误码的回调处理函数 404: handler404, 500: handler500 &#125;&#125;);jqxhr.done(successHandler);jqxhr.fail(failureHandler); 5.6 链式写法 [建议] 尽量使用链式写法，而不是用变量缓存或者多次选择器方法。 示例： 123456// bad$("#myDiv").addClass("error");$("#myDiv").show();// good$("#myDiv").addClass("error").show(); [建议] 当链式写法超过三次或者因为事件绑定变得复杂后，使用换行和缩进保持代码可读性。 示例： 12345$("#myLink") .addClass("bold") .on("click", myClickHandler) .on("mouseover", myMouseOverHandler) .show();]]></content>
      <categories>
        <category>开发规范</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
        <tag>js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditorConfig 代码格式定义]]></title>
    <url>%2F2018%2F03%2F12%2Feditorconfig%2F</url>
    <content type="text"><![CDATA[1 配置项说明 2 通配符（Wildcard Patterns） 3 配置示例 在项目开发过程中，如果涉及到多人一起合作开发，以及在开发过程中，还会有代码 review 等相关操作，这时候，团队内一种统一风格的代码编写方式显得尤为重要。而目前市面上的代码编辑器又非常多，代码格式化的工具或插件等也有很多，如要达到我们的风格一致的要求，借助工具的帮助最为直接。 EditorConfig 即是一款定义各代码风格的工具，其在很多工具中都能得到支持，如：WebStrom、Atom、Sublime、VSCode等。 1 配置项说明 EditorConfig 文件使用 INI 格式，允许在分段名（section names）中使用 and，分段名是全局的文件路径，格式类似于 gitignore。斜杠（/）作为路径分隔符，# 或 ; 作为注释。注释应该单独占一行。 EditorConfig 文件使用 utf-8 格式，crlf 或 lf 作为换行符。 &#123;.line-numbers&#125;1234567891011121314151617181920212223# 表明是最顶层配置文件，发现设为 true 时，才会停止查找 .editorconfig 文件root = true# 缩进样式，可以设置为 tab 或 space 两个值indent_style = space# 当缩进样式设置为 space 时，用来设置每次缩进相当于多少列indent_size = 4# 当缩进设置为 tab 时，用来设置每次缩进相当于多少列代码tab_width = 4# 定义行末采用什么符号来进行换行，可以选择包括：lf、cr 和 crlfend_of_line = crlf# 编码格式，支持： latin1、utf-8、utf-8-bom、utf-16be 和 utf-16le，不建议使用 utf-8-bomcharset = utf-8# 是否除去代码行末的任意空白字符，true 或 falsetrim_trailing_whitespace = true# 是否以一个空白行结尾文件，true 或 falseinsert_final_newline = true 以上即是相关配置项，及其说明。目前所有的属性名和属性值都是大小写不敏感的，编译时会自动将其转换为小写。通常，如果没有明确指定某个属性，则会使用编辑器的配置，而 EditorConfig 不会处理。 另外，并不是所有的编辑器插件都支持以上全部配置属性，项目 Wiki 上有兼容配置属性的详细参考。 推荐不要指定某些属性，如，tab_width 不需要特别指定，除非它与 indent_size 不同。同样的，当 indent_style 设置为 tab 时，不需要配置 indent_size ，这样方便阅读者使用他们习惯的缩进格式。仍没有规范化的属性，就最好不要设置它，如：end_of_line。 2 通配符（Wildcard Patterns） 通配符 说明 * 除路径分隔符 / 外匹配所有字符串字符 ** 除路径分隔符 / 外匹配所有字符串字符 ? 匹配所有单个字符 [name] 匹配 name 字符 [!name] 匹配非 name 字符 {s1,s2,s3} 匹配任意给定的字符串，通过逗号分隔 特殊字符需要通过转义符进行转义，使得特殊字符不会被当做通配符解析。 3 配置示例 &#123;.line-numbers&#125;12345678910111213141516171819root = true[*]charset = utf-8insert_final_newline = true[*.&#123;js,html&#125;]indent_style = spaceindent_size = 4trim_trailing_whitespace = true[*.&#123;less,scss&#125;]indent_style = spaceindent_size = 2trim_trailing_whitespace = true[&#123;package.json,.travis.yml&#125;]indent_style = spaceindent_size = 2]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>EditorConfig</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 博客升级并上传 github]]></title>
    <url>%2F2018%2F02%2F27%2Fupdate-hexo-blog%2F</url>
    <content type="text"><![CDATA[1 问题有哪些 2 配置文件分散与升级的矛盾 2.1 hexo 配置 2.2 NexT 主题配置 2.3 自定义样式 3 github 同时托管源码与静态站点 3.1 git ignore 配置 3.2 github 配置 4 博客编写编辑器 Hexo 的主程，因为在不断的升级变化，在最初搭建博客时，使用的版本是 3.2.0，目前已经发展到了 3.5.0。另外，还有其他一些相关的插件，包括主题等都有了相应的更新，因此，近期考虑了一下将整体升级一次。 其中遇到了不少的问题，这里将这些问题记录一下。 1 问题有哪些 hexo 本身就有配置文件，主题也有配置文件，多位置配置，导致升级非常麻烦 博客使用 github page 托管，但 markdown 源码又是使用其他的库来保存，导致管理分散 在写博客的过程中，没有找到合适顺手的编辑软件，很不方便 2 配置文件分散与升级的矛盾 hexo 的配置文件位置 _config.yml ，以及相应安装主题的配置文件 themes/xxxx/_config.yml ，这两者在一定程度上加大了程度升级的复杂度。 以我安装的 NexT 主题为例，它本身的配置项非常的多，再加上其也在不断的升级更新，如果我们的配置文件存储位置在其项目工程目录以内，就导致了主题在更新升级时，可能会存在被覆盖的风险。 这些还只是配置文件，如果再还有对页面样式、模板等内容进行过自定义，这些内容就更容易被覆盖。因此，我急需将这些内容移出，并独立于主题的工程目录。 所幸，hexo 官方本身也考虑到了这一点，支持 数据文件夹 的配置使用，source/_data/ 目录。 2.1 hexo 配置 配置路径 1_config.yml 配置内容 为了配置项的相对集中，该配置文件中的某些相关的内容，可以移入数据文件夹，也主题 NexT 的配置相结合。必需在该路径下配置的有： theme deploy Directory 中的： skip_render symbols_count_time 其他的配置项可以保持原有值不修改，具体的配置值可以拷贝一份到数据文件夹。 2.2 NexT 主题配置 配置路径 1source/_data/next.yml 配置内容 将 hexo 配置中的必须配置项以外的项目，全部拷贝一份到 next.yml ，以及将主题 next 的配置文件(themes/next/_config.yml)中全部配置文件，再对相应的配置项进行修改。 前提条件是，使用 next 的主题版本在 6.0.x，详细的说明，可以参考官网帮助手册。 2.3 自定义样式 对于 NexT 主题，在某些情况下，个人还是希望能对其样式有所修改，同时期望不会影响到 NexT 本身的升级，因此，可以借助数据文件夹的思路，将个性化的样式表，建于此处。 配置路径 1source/_data/styles.styl 3 github 同时托管源码与静态站点 一般的思路，并且现在大多的博客上所说明的，一般是 github pages 如何部署，结合 Hexo 的话，就是如何配置好 github 的部署参数后，再执行 hexo d 命令成功完成部署就基本结束了。 但我们还有一部分，我们在博客编写过程中，还有很多的 markdown 源码，这些内容，我们要如何来进行管理，难道一个仓库就只能用于托管一个静态站点吗？ 显然不是的，我们的静态站点，只占用了仓库的一个分支 master， 也就是说，我们完成可以建立其他的分支，来用于存储我们的 markdown 源码。 3.1 git ignore 配置 工程目录下，因包含有很多编译输出的结果，以及 nodejs 模块目录，而这些内容，是不需要提交到仓库的。 12345678# .gitignore.idea.deploy_gitnode_modulespublicthemesdb.jsonpackage-lock.json 3.2 github 配置 因是升级处理该系统，因此，原本仓库中已经存在有相关内容，现在的做法是，将 Hexo 的工程源码，提交到一个新建的分支中。 123456789101112131415161718# 在根目录下进行 git 初始git init# 配置远程仓库参数git remote add origin https://github.com/lfire/lfire.github.io.git# 新建一个远程分支 srcgit checkout -b src# 提交所有源码git add .git commit -m "init the blog source"git push origin src# 补充一个有用的命令# 因误操作，创建了一个错误的分支# 需要删除# git push origin --delete xxxx 这样，分支 src 就将所有相关的源码进行了管理，而 master 分支则管理了 github pages 的站点。 4 博客编写编辑器 最初，一直没能找到一个得心应手的编辑器，后面选择了一款付费软件， Cmd Markdown，但对于 Hexo 的支持，只能说是到达 markdown 的支持，如果要细化到 Hexo 本身，这就有差距了。还有就是，Cmd markdown 使用的是其自建的图床，个人有点担心，还是希望可以自己掌握所有这些资源的去处，最后选择了配置七牛。 另外一个方面， vscode 和 atom 的发展速度确实惊人，这两款软件提供了大量的插件可用，与我个人使用习惯一匹配，个人最后选择了 Atom 。 其中有一个重要的插件，可以提一下，Markdown Preview Enhanced]]></content>
      <categories>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Agile知多少]]></title>
    <url>%2F2017%2F12%2F05%2Fabout-agile%2F</url>
    <content type="text"><![CDATA[1 网友看敏捷 2 Agile，何为敏捷？ 3 Agile，差别在哪（与传统开发交付方法相比较） 4 Agile，优势在哪？ 5 敏捷的价值观（Values） 6 敏捷的原则（Principes） 7 敏捷开发管理实践 7.1 Scrum 7.2 Lean 7.3 XP 7.4 其它 8 Scrum 8.1 Scrum 3-3-5-5 特性 8.2 Scrum敏捷团队中的角色 8.3 Scrum敏捷团队工作流程 8.4 主要的敏捷开发工程实践 随软件的不断复杂，相应的软件开发思想也在不断的发展。敏捷开发就是其中所提出来的一种，相应的实践也有很多，目前的发展趋势也非常火爆，今天对于这个方向，梳理一下一些基础的内容，用于初步了解敏捷的思想，以及一些基本的概念。 1 网友看敏捷 敏捷，往小了说是改进了开发方法，往大了说是革了瀑布流式的命——把产品开发引向了快速迭代、小步快跑的路线上。 2 Agile，何为敏捷？ 敏捷开发是一个灵活的开发方法，用于在一个动态的环境中向干系人快速交付价值。其主要特点是关注持续的交付价值，通过迭代和快速用户反馈管理不确定性和拥抱变更；它承认个人才是价值的最终源泉，强调通过有效的个人激励，提升团队的工作绩效。 3 Agile，差别在哪（与传统开发交付方法相比较） 敏捷 VS 传统 &lt;===&gt; 价值驱动 VS 计划驱动 4 Agile，优势在哪？ 拥抱变化：通过短周期迭代，尽可能早的交付可用的迭代版本来拥抱和适应变化 进度可视：可视化的评估进度模式在传统模式（瀑布）里面难以做到 注重客户 团队沟通 自管理 … 5 敏捷的价值观（Values） 个体与互动 高于 流程与工具 工作的软件 高于 详尽的文档 客户合作 高于 合同谈判 响应变化 高于 遵循变化 尽管右侧项有其价值，但敏捷更注重左侧项的价值。 6 敏捷的原则（Principes） 我们最重要的目标，是通过持续不断地及早交付有价值的软件，使客户满意。 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。 业务人员和开发人员相互合作，项目中的每一天都不例外。 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。 可工作的软件是进度的首要度量标准。 敏捷过程提倡可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。 以简洁为本，它是极力减少不必要工作量的艺术。 最好的架构、需求和设计出自自组织团队。 团队定期地反思如何能提高成效，并依此调整自身的举止表现。 7 敏捷开发管理实践 7.1 Scrum Scrum 包括一系列实践和预定义角色，是一种灵活的软件管理过程。 7.2 Lean Lean（精益开发） 从最终用户的视角上观察生产流程，视任何未产生增值的活动为浪费，并通过持续地消除浪费，实现快速交付、高质量与低成本。 7.3 XP XP（极限编程） 由 Kent Beck 提出的一套针对业务需求和软件开发实践的规则，它的作用在于将二者力量集中在共同的目标上，高效并稳妥地推进开发。 7.4 其它 OpenUP DSDM FDD … 8 Scrum Scrum指的是英式橄榄球中一股脑争球这一战术或行为。 Scrum作为软件开发过程框架，是这样一种方式：大家一拥而上，团队是球员，球是产品目标，人员环环相扣，围绕着产品目标进行工作。 8.1 Scrum 3-3-5-5 特性 Roles 角色（3） Product Owner 产品所有者 Scrum Master 敏捷教练 Team 团队 Artifacts 工件（3） Product Backlog 产品Backlog Sprint Backlog 迭代Backlog Burndown Charts 燃尽图 Features 特性（5） Courage 勇气 Openness 开放 Commitment 承诺 Focus 专注 Respect 尊重 Ceremonies 仪式（5） Sprint 迭代 Sprint Planning 迭代计划会议 Daily Meeting 每日立会 Sprint Review 审核会议 Sprint Retrospective 回顾会议 8.2 Scrum敏捷团队中的角色 Product Owner 产品所有者 代表客户的意愿，主要负责编写用户故事，排出优先级，并放入 Product Backlog，从而使项目价值最大化。 Scrum Master 敏捷教练 保证 Scrum 成功的牧羊犬，负责 Scrum 过程正确实施和利益最大化的人，确保它既符合企业文化，又能交付预期利益。 Team 团队 对每一次迭代和整个项目共同负责，在每个冲刺中通过实行自管理、自组织，和跨职能的开发协作，实现冲刺目标和最终交付产品。 8.3 Scrum敏捷团队工作流程 在 Scrum 项目管理过程中，一般产品负责人获取项目投资，并对整个产品的成功负责。他会协调各种利益干系人，确定产品订单中（Product Backlog）初始的需求清单及其优先级，完成项目的商业价值分析和项目整体规划，并任命合适的 Scrum 教练开展项目工作。 Scrum 主要输入输出： 产品订单（Product Backlog） 冲刺订单（Sprint Backlog） 燃尽图（Burndown Chart） 新的功能增量 8.4 主要的敏捷开发工程实践 迭代式开发：每次按照相同的开发方式短期的开发软件的部分 持续集成：英文是 Continuous Integration，在敏捷语境下缩写 CI 多级项目规划：是指以迭代开发为基础，形成多层次的、逐步细化的项目或产品计划 完整团队：如 Scrum 团队是基于功能开发而组成的跨职能、自我管理团队 ATDD（体验测试驱动开发）：实现某个具体功能之前，首先编写功能测试或验收测试用例，从系统功能角度驱动开发过程 结对编程：在敏捷软件开发的各种实践中，结对编辑（Pair Programming）是特别有争议的 确定冲刺计划：团队和PO共同决定在接下来的冲刺周期内的目标以及哪些功能和任务需要完成 故事点计算：故事点估算用于评估为了交付一个用户故事所包含的所有努力（team effort），用户故事的复杂度（complexity），风险，以及所有其他需要考虑的元素 需求订单（产品订单）：一张记录用户需求的列表，包括产品所有需要的特征]]></content>
      <categories>
        <category>敏捷开发</category>
      </categories>
      <tags>
        <tag>agile</tag>
        <tag>敏捷开发</tag>
        <tag>scrum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署FRP服务 实现内网穿透]]></title>
    <url>%2F2017%2F11%2F15%2Fdeploy-the-frp-server%2F</url>
    <content type="text"><![CDATA[1 什么是 frp 2 准备 3 服务端环境搭建 3.1 frp 配置 3.2 nginx 反向代理配置 3.3 服务端启动 4 客户端环境搭建 4.1 客户端环境配置 4.2 本机 wamp 环境 &amp; 虚拟主机配置 4.3 客户端启动 4.4 测试连接效果 5 微信开发调试环境搭建 5.1 服务程序开发 5.2 微信公众号配置 5.3 接口测试 6 几个有用的点 先抛出几个问题： 我们有在本地开发的某一个 B/S 程序，希望给客户直接在线演示，怎么办？ 程序在内部开发调试阶段，对于某一个具体的测试问题，我不想发布到生产，只是想测试帮忙先看一下，OK 了后，我再发布，这样怎么办？ 微信公众号开发，现在这么火，烦人的，我需要调用微信公众号的接口，但微信的接口服务配置时，只接受一个公网的认证链接，这时候，难道我真的要每开发一个很小的变动，调试时仍需要不停的与线上部署服务器进行改动同步，就没有更简单的开发调试方法了吗？ … 现在来了，这些似乎难以搞定的事情，好像现在都有一定的共同性： 我的资源在内网环境，而且这样是为了方便我本人很好的修改，并对不同的需求进行快速的响应。 我需要将我本地的相关内容公开到公网环境去，方便相关的人直接查看到我本地的效果 与相关的第三方对接时，第三方只能识别公网上的相关资源，而不能穿透内网 最最核心的问题是，在没有公网 IP 的情况下，我希望将我的资源挂载到公网。 当然，这中间可能有很多的解决方案，比如：花生壳、ngrok、go-proxy等等，但这里我想分享的方案是 frp 服务，以这款工具所提供的能力来实现内网穿透，并选取我们以上所提到的一种场景——微信开发调试，来实际展示一个实例。 1 什么是 frp frp 是一个高性能反向代理应用，可用于实现内网穿透，支持 TCP、UDP、HTTP、HTTPS 等协议，以此将内网资源对外网提供服务。 其中更详细的一些介绍，以及使用细节，官方的《中文文档》 有很详细的解释和说明，大家也可以直接参考。 2 准备 在使用之前，你需要准备一台拥有公网 IP 的服务器（如：阿里云、linode等），一台内网环境下的主机（一般就是你个人的 PC 机），一个域名（在服务器上开启虚拟主机，可以通过域名中的不同子域名，实现端口的重用），SSH 工具。 因国内的 VPS 一般需要通过备案后使用，使用会相对较为麻烦，因此，如果本身就有，就直接使用，如果需要新买，那最好是通过 linode 等这些相关的国外服务器平台购买，这样会比较方便。 3 服务端环境搭建 在网方的发布平台 releases，我们下载最新的发布版本（当前最新的版本为 V0.13.0）。其中我们需要选择对应的版本，其中服务器，常见的系统环境版本，一般为 linux 64 位，因此，我们一般情况选择：frp_0.13.0_linux_amd64.tar.gz。 我们将压缩包中的服务端程序（frps）和服务端配置文件（frps.ini）提取出来，如下图。 3.1 frp 配置 服务器的配置文件，官方手册中有详细的解释，我这里贴出本次我所搭环境的示例： 123456789101112131415[common]bind_port = 7000vhost_http_port = 28088subdomain_host = frp.domain.com# 这里是为了安全的考虑，加入一个身份认证的 token 配置，这里只要服务端和客户端配置一致即可privilege_token = xxxxxxxxxxxxdashboard_port = 7500dashboard_user = admindashboard_pwd = adminlog_file = ./frps.loglog_level = infolog_max_days = 3 3.2 nginx 反向代理配置 其中，因为我的服务器上有相关其他的程序共用，80 端口上交给了 nginx ，而在微信的接口配置时，只能是 80 or 443 端口，因此，这里我还借用了 nginx 的反向代理功能，配置如下： 12345678910111213141516server &#123; listen 80; server_name frp.domain.com *.frp.domain.com; location / &#123; proxy_pass http://frp.domain.com:28088; proxy_set_header Host $host; root /usr/share/nginx/html; index index.html index.htm index.php; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 这里启用了泛域名解析，考虑的是，这个服务开启后，我们可以通过这种方式提供给多人使用，不同的人员，可以启用一个对应的子域名，如：张三（zhangsan.frp.domain.com）、李四（lisi.frp.domain.com）、… 3.3 服务端启动 1234# 常规启动./frps -c frps.ini# 或者，使用 nohup 方式，启用后台运行模式，这样就可以避免命令行工具关闭后，服务中断的情况nohup ./frps -c frps.ini &amp; 4 客户端环境搭建 客户端在配置之前，同样的请在官方下载与自己系统对应的程序包，解压出其中的客户端程序（frpc.exe）和配置文件（frpc.ini）。 4.1 客户端环境配置 与服务端配置相对应的客户端配置如下： 12345678910111213[common]# 公网服务器的 IP 地址server_addr = xx.xx.xx.xxserver_port = 7000# 这里需要与服务端所配置的 token 值一致privilege_token = xxxxxxxxxxxx[web]type = httplocal_port = 80# 因启用了泛域名解析，不同的人员，可以使用各自不同的子域名，只要不重复，这样可以方便多人共用服务端资源subdomain = liyzcustom_domains = frp.domain.com 示例中，我启用了我的个人子域名（liyz），那配置对应的访问域名为：liyz.frp.domain.com。 4.2 本机 wamp 环境 &amp; 虚拟主机配置 示例中主要是针对 B/S 架构的应用进行解释，因此，这里我在本地通过 wamp 搭建了一个基本的 WEB 服务，并开启了一个相应的虚拟主机，配置如下： 1234567891011&lt;VirtualHost *:80&gt; ServerName frp.domain.com ServerAlias liyz.frp.domain.com DocumentRoot c:\project\wumi\tmp\public &lt;Directory c:\project\wumi\tmp\public\&gt; Options Indexes FollowSymLinks AllowOverride all Order deny,allow Allow from all &lt;/Directory&gt;&lt;/VirtualHost&gt; 这只是基本的服务配置，大家可以根据自己的实际应用需要，进行更多相关配置。 4.3 客户端启动 1.\frpc.exe -c frpc.ini 4.4 测试连接效果 公网服务器，启动 nginx，本地启动 wamp 服务，并在 wamp 虚拟主机配置的对应目录中（c:\project\wumi\tmp\public），新建 index.html 文件。浏览器打开： http://liyz.frp.domain.com 访问。 可以查看到正确的访问返回，成功！ 5 微信开发调试环境搭建 微信公众平台中，关于接口配置信息的说明是，只支持：80 &amp; 443，两个端口，这也就是前面，为什么要启用 nginx 服务的原因。 为了演示方便，这里仅采用公众平台测试账号。 5.1 服务程序开发 为了达到演示效果，这里在 thinkphp 的基础上，用 PHP 简单写了一个对接程序，基础代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace app\index\controller;use EasyWeChat\Foundation\Application;use think\facade\Config;class Index&#123; /** * 微信服务对接接口 */ public function wxServer() &#123; $opt = Config::get('wechat.dev_server'); $app = new Application($opt); $server = $app-&gt;server; $server-&gt;setMessageHandler(function ($message) &#123; // $message-&gt;FromUserName // 用户的 openid // $message-&gt;MsgType // 消息类型：event, text.... // 当 $message-&gt;MsgType 为 event 时为事件 if ($message-&gt;MsgType == 'event') &#123; switch ($message-&gt;Event) &#123; case 'subscribe': return "感谢您关注！"; break; default: break; &#125; &#125; &#125;); $response = $server-&gt;serve(); $response-&gt;send(); &#125; /** * 测试调用微信 API */ public function testWx() &#123; $opt = Config::get('wechat.dev_server'); $app = new Application($opt); $userService = $app-&gt;user; $users = $userService-&gt;lists(); dump($users); $openId = 'oH9qBjuW0qt7Ub8kYN4G6PuZrLRw'; $user = $userService-&gt;get($openId); dump($user);// $broadcast = $app-&gt;broadcast;// $r = $broadcast-&gt;sendText("大家好！");// dump($r); &#125; /** * 服务首页 */ public function index() &#123; echo "Hello, frp server ok!"; &#125;&#125; 简化微信的相关接口对接开发，这里使用了 easywechat 提供的封装程序，具体详细使用方法，可以参考其官网。 5.2 微信公众号配置 因开发了 PHP 对接程序，接口配置的 URL 为： http://liyz.frp.domain.com/Index/wxServer 根据网速，大概最多几移后，系统会提示配置成功。 5.3 接口测试 在逻辑中，我们开发了一个 testWx 逻辑页面，我们可以通过访问，http://liyz.frp.domain.com/Index/testWx ，其中实现：获取公众号用户列表，以其中一个用户的信息。 需要说明的，公众号测试平台中的某些接口，在实际开发过程中，是没有相关权限的，比如：群发接口，因此，建议在有资源的情况下，还是单独的申请注册一个认证的订阅号，或是服务号来开展测试调试工作。 6 几个有用的点 80 端口共用，在一般的使用场景中，绝大多数的 WEB 服务是基于 80 端口提供服务的，因此，我们的 frp 不大可能在某一服务器上独占 80 端口资源，因此，这里启用了 28088 端口的兼听，通过 nginx 反向代理将某一域名的 80 端口请求转发到 28088。 泛域名解析，再结合 frp 的 subdomain 配置，实现多人共用 frp 服务器资源。 通过 frp 的转发，能实现本地基于域名的虚拟主机服务，示例中是通过 wamp 的服务实现的，当然，你也可以安装 nginx 等其他相关服务程序。]]></content>
      <categories>
        <category>环境配置</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>proxy</tag>
        <tag>内网穿透</tag>
        <tag>微信本地开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetbrains系列产品激活服务器搭建]]></title>
    <url>%2F2017%2F11%2F10%2Fjetbrains-ide-active-server%2F</url>
    <content type="text"><![CDATA[1 关键操作 2 自建公网服务器 3 配置参数说明 4 结合 nginx &amp; 自有域名 配置 对于开发者来说，一款合用的开发工具非常影响其开发质量和速率，而纵观所有工具，开发IDE方面，Jetbrains 的产品值得我们称道。他设计的合语言开发 IDE，给我们提供了很好的开发体验，但这其中有一个很难为情的问题，对于我们开发者来说，其正版授权价格一时无法承受，特别是对于一些学习编程的初级入门者来说，就更为困难。 因此能有一种好的方式来使用该公司产品，也是对于个人体验，以及编程能力的提升。这里总结了一种自建服务器来激活全系列产品的方法。（当然，对于有能力的开发者来说，还是建议直接购买。） 开始，我们得先感谢这款工具的开发者，lanyus，目前该工具发布的版本已到 1.5 。 而针对于相关的使用方法，特别是当自己没有相关公网服务器的情况下，在自己本地机器上运行时，如何使用，有详细的说明，具体可以访问说明教程。 1 关键操作 下载服务搭建程序 备份链接: https://pan.baidu.com/s/1dGxchlJ 密码: 1k6w 解压，使用 IntelliJIDEALicenseServer_windows_amd64.exe 在相应 idea 注册界面选择 License server，填写 http://127.0.0.1:1017，（据说1017是作者女票生日，像作者女票致敬-_-） 2 自建公网服务器 同样是下载服务器搭建程序包 备份链接: https://pan.baidu.com/s/1dGxchlJ 密码: 1k6w 执行 tar zxvf IntelliJIDEALicenseServer(v1.5).tar.gz，解压文件，文件内容如下。 根据自身机器的系统情况，选择对应的程序，本例中是：linux 64 位系统，所以我将 IntelliJIDEALicenseServer_linux_amd64 单独提出，并重命名为 IdeaServer。（文件名太长，命令也太长） 运行服务程序，nohup ./IdeaServer -p 1024 -prolongationPeriod 9999999999999999 &gt; idea.log 2&gt;&amp;1 &amp;，其中采用了 nohup 运行方式，并将日志记录在了 idea.log 文件中。 在激活时，激活服务器的地址就是：http://xxx.xxx.xxx.xx:1024，其中有 x 就是你对应服务器的 IP 地址。 3 配置参数说明 -l 指定绑定监听到具体哪个 ip (私用，不共享) -u 用户名参数，当未设置 -u 参数时，且计算机用户名为 ^[a-zA-Z0-9]+$ 时，使用计算机用户名作为 idea 用户名 -p 指定监听的端口 -prolongationPeriod 指定过期时间参数 4 结合 nginx &amp; 自有域名 配置 要记住某一服务器的 IP 地址，总是不那么容易，而相对的，记住一个相应的域名就要容易得多。 因此，我们如果有一个域名，如：your.domain.com，我们希望直接使用该域名地址来实现激活服务，但同时，对于 80 端口，一般常用的 WEB 服务，都是基于该端口来提供服务，因此，如果某一程序独占该端口过于浪费，这样，我们可以借用 nginx 的虚拟主机和反向代理能力，将 your.domain.com:80 上的请求，直接转发到我们的激活服务地址和端口。 12345678910111213141516server &#123; listen 80; server_name your.domain.com; location / &#123; proxy_pass http://127.0.0.1:1024; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; access_log off; error_log /dev/null;&#125; 经过如上配置后，你就可以直接使用 http://your.domain.com 直接充当激活服务器了。]]></content>
      <categories>
        <category>工具</category>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>jetbrains</tag>
        <tag>webstorm</tag>
        <tag>phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂前端项目开发思考模型——H5小游戏]]></title>
    <url>%2F2017%2F10%2F31%2Fgame-with-h5%2F</url>
    <content type="text"><![CDATA[1 项目效果演示 2 为什么可以说复杂 2.1 整体的游戏执行流程 2.2 界面中元素众多 2.3 界面元素涉及状态切换&amp;动画执行 3 需要如何考虑 3.1 样式部分 3.2 HTML部分 3.3 JS部分 3.4 什么能交给工具 近期因为在筹划阐述前端开发工作中的各种复杂场景，并将其中可能用得上的思想讲明白，比如：模块化开发、自动化构建、工程化等，在每一个方向上，都是用于解决我们在项目开发过程中，所遇到的问题，以及提升工作效率的考虑，以此提升开发工作的趣味性。 Not just do it, but enjoy it. 以此为砖，用以引玉。 正好近期也接受到了一个项目——《大富翁》小游戏，对于该项目的初步分析，并结合到我的想法，可能适合作为“复杂场景”的一个引子，我希望可以以该项目的实施及思考过程，来实例化的描述一下整体的一个解决思路。暂且叫其为：思（什）考（么）模（鬼）型。 1 项目效果演示 先上个图，大致看一下最后的效果，没有将所有出现的情况全部展示。 2 为什么可以说复杂 2.1 整体的游戏执行流程 这张图中可以看出游戏在执行过程中的逻辑流程，其中大部分都会涉及到前端交互的响应变化，因此其中前端交互流程复杂。 2.2 界面中元素众多 其中涉及到场景的元素非常多，各元素之间的排列，以及形状尺寸各不相同。这种场景下，给界面的兼容适配带来了难度。 2.3 界面元素涉及状态切换&amp;动画执行 其中小狐狸的状态涉及到3种：静态、向左走动、向右走动。 掷出骰子后，界面其他元素的交互触发需要锁定，并且，各元素的执行有明确的先后顺序，需要类似时间轴的概念来统一协调管理。 3 需要如何考虑 3.1 样式部分 界面非常的个性化，导致界面的样式布局上，我们很多场景需要使用背景图片来进行处理，另外，加上在不同尺寸终端上展示适配需求，更加使得整体问题变得复杂难解。 需要解决的点： 各终端不同尺寸适配 大部分为不规则的背景元素，CSS的编写过程，元素尺寸的快速管理 页面动画过程中，元素位置的定位问题 页面的样式有相近部分，如：弹窗，如何达到封装共用 各终端不同尺寸适配 目前市面上，可以统计到的不同终端尺寸，没有上百，也有几十，因此，在H5开发过程中，样式开发如何适配不同尺寸的显示屏，成为了我们这块所必须面对的首要问题。 1. 媒体查询（media query） 所涉及到的情况实在是太多，这导致，不同尺寸区间的细分会非常的复杂，而且，每一个尺寸区间下的都需要或多或少的人工干预调整，这在工作量上已经是无法实现的，还没考虑其中所涉及到的测试检验等等一系列的问题，所以，该方法基本可以排除。 2. 百分比 在CSS开发过程中，我们可以尝试使用百分比的方式来定位各不同元素在场景中的位置，以期在不同尺寸下达到同等比例的缩放。 这种思路很好，但技术选择方向上，百分比带来了很多的不可测量性，简单的来说，你拿到一个设计稿，其中一个元素相对于整体场景，或是另一个元素，具体较为精确的距离是百分之多少，这个没办法很直接的测量，因此，这种情况下，很多是由前端人员，依“手感”来细微的调整元素的位置，一个百分点，甚至零点几个百分点的来调整，而且调整完成后，由于各元素之间细微的误差积累，等放入另一个尺寸下时，你可能会发现，各要素的偏差很大，已经出现了我们常遇到的不兼容。 总结来说，就是工作量巨大，而且不兼容。 3. REM REM是我实践过程中，认为的终极解决方案。当然，这其中我们要感谢很多在这方面提供解决方案的开源付出，如：lib-flexible，这就是其中的一个，具体的设计思路，可以详细去查阅本方向上的资料，这里不再展开。 附加的，会产生出另一个问题，REM，这个单位毕竟不是PX，仍需要换算。这里也同样有相应的解决方案，我们可以借用自动化的构建工具，实现rem和px之间的自动转换，px2rem，可以与gulp或grunt等构建工具集成，实现自动转换。 自动解析后： 元素尺寸的快速管理 在场景中，出现了很多个性化的元素，其中的实现，很多是以背景图片来实现，之所以选择这种方式，是借助了 cssgrace 中的一个特性：可以通过 image-width、image-height 两个动态属性，来自动的获取到图片的宽高尺寸。 编译解析后 这样不但可以将图片尺寸的管理交托给自动化的构建脚本，提升CSS开发中的效率，并且可以明显降低设计稿发生修改所带来的代码改动成本。 如若过程中，设计稿发生修改，某一个元素的尺寸发生了稍微的改动，这种方案下，我们只需要重新更新切图，再执行一次自动构建任务，中间的代码不需要任何的改动，高效而准确！ 元素定位 得益于 REM 方案带来的方便，我们只需要解决一种尺寸稿件下的准确定位，再附加上自动构建任务中，将 PX 自动转换为 REM 单位，其中的源码是 PX 单位，而构建出的成品代码是 REM 单位，这样实现了代码对于开发人员的可理解，以及代码的各尺寸终端的可兼容，两者兼顾。定位问题，在本次的开发过程中，直接采用的是针对于 750px 尺寸下的精准定位。 如图中所示，小狐狸的路径节点相对于 750px 下的定位，全可以一次性的在稿件中标注定位，并写好相应的class，自动构建类的脚本，会自动将相关的单位进行解析转换。 样式封装共用 相信大家，在前面的几组对比图中，就可以发现，开发中有用到 LESS 来结构化的开发样式布局。类似于 LESS 的CSS预处理插件还有很多，我们可以自己查询相关的资料，这里希望能过这种预处理的插件，给我们带来了 CSS 模块、函数式的编辑体验，这样可以大增强样式表的结构可读性，同时也可以很好的提升样式表产出的规范，以及逻辑准确性。重要的是，其中可以很大程度的减少我们相似规则，或是嵌套规则之间的代码量。 在本段示例规则中，弹窗的整体内容进行了一次性编写，其中各不同弹窗中的 .bts 和 .bt 可以共用，并且结合共用规则的封装，每一个不同弹窗，都与规则 .pop_cont 组合，其中具有相同表现的弹窗（.p_c_free &amp; .p_c_props）直接共用规则。其中各规则之间的嵌套层级非常明确清晰，对于规则的阅读以及整体统一管理非常方便，从而屏蔽了普通 CSS 在编写过程中的，可能比较分散，规则识别路径原则不一致，给编写和维护带来困惑的弊端。 总之（总而言之，言而总之） 对于样式的处理，我们借助了几个不同的方案，进行了一种组合搭配，实现了对于移动端尺寸适配，以及样式结构化、模块化的开发体验。 3.2 HTML部分 HTML部分的提出，对于本项目中的场景，可能不是十分的贴切，这里最为主要的点是需要解析 HTML 模块化的问题，引出这个需求的考虑有以下几点： 页面结构更为清晰 模块之间可以达成共用 IDE 等相关软件的响应速度影响 减少重复代码在不同文件中的重复出现 这是本次项目中的主要 HTML 页面代码结构，其中有出现 include 的语法，而这种就是对于分模块化开发的一种实践方式，集成的是 nunjucks ，它的引入给 HTML 带来了很多模块化方向的能力提升，具体的特性，可以详细阅读其手册。 回到项目中， head_wap.html 这是文件所需要引入的相关样式及JS库的部分，这是我们项目中经常在各个页面重复出现的部分，因此，这里对该部分进行了一次提取，在不同页面，只需要一名 include 就可以解决这种重复问题，更好的达到统一管理的需求。 而对于另一个实操过程的痛点，即，我们在开发过程中，一般会选用相关的代码编辑器，这里是 webstorm IDE，而正是因为这种类型工具的使用过程中，工具本身对于代码文件需要内建很多的索引，用以提供相关功能，而这个内建索引及维护过程中，需要消耗很大的系统性能，这种情况在大文件编辑时尤为明显，因此，为了在这个方向提升我们的开发效率和体验，我们通过模块化的分割，将一个大文件，拆分为各相对较小的文件，这样也就可以避免在编辑器上的体验下降的问题。 3.3 JS部分 JS部分中，我们需要整理和注意的点其实非常的多，其中所涉及到的模块，功能、性能、安全、规范……，等等，各个词，甚至都可以拓展开为一个专门的课程，可见在这个大方向上，问题的复杂程度。 在本次的项目中，也只是一个很小的引子，希望可以引申出对于这些方向问题的考虑，而实际的使用，可能并没有涉及。 模块化 有点牵强，但可能如前面所述，可以是一个引子。这里的模块化，也就只是停留在了函数的简单封装，能有规范、明确的相关参数说明，以及相关的调用解析。 这些也仅仅只是JS模块化的冰山一角，问题（砖）的抛出，只是为了引出项目实施过程中，对于模块化开发的思考（玉）。 其过程中，可能有好几个词可以来提及，commonjs、AMD，这些思想，都是为了解决一种（一系列）具体的问题而产生，因此，要读懂这其中的内容，也必须要能理解这种问题是什么，痛到底在哪里，这里也仅仅只能讲到这个层次，更多的内容，后面有机会，我再会详细的来展开。 3.4 什么能交给工具 前面无论是示例，又或是说明，都有多次的提到模块化，而这种模块化，更多的层面是面向我们开发者，是为了：让开发者有更好的编辑体验，而对于机器来说，最终是需要运行，因此，这中间的一个衔接，都是可以交给工具来完成的。 LESS不能直接在浏览器直接识别解析 因此有了类似于 gulp-less 的解析编译工具，可以方便快捷高效的将你的 less 代码转换为对应的 CSS。 include是什么鬼，浏览器怎么认识 这个梗主要是用来给你人看的，而浏览器看不到它，中间就是因为有 nunjucks 的存在，解析了人机之间的区别。 我只能理解PX，但机器需要REM px2rem 的引入，正好解决了这种人与机器之间的不同需要点，人能很好理解，机器又能很好适配。 …… 工程化的过程，其实就是模块化、自动化之间的一种更业务层次的组合，每一个复杂业务场景出现时，最为直接的问题解决方向就是如何便于人的理解，又能便于机器的执行，这些不同层次问题的思考解决过程，其实就是我们所需要的思考模型。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown编写规范API文档]]></title>
    <url>%2F2017%2F10%2F23%2Fmarkdown-api%2F</url>
    <content type="text"><![CDATA[1 学生管理（接口包） 1.1 接口标题（格式示例） 1.2 单个学生登录（DEMO） 随技术不断发展，服务端和前端及其各方的逻辑交互，走向了一种更为规范的道路。因此，从个人能力，或是团队协作的角度出发，编写规范的 API 文档成为了一种不可缺少的能力。 以下是以 markdown 文档方式编写的一组 API DEMO ，选用 markdown 作为 API 编写工具是因为，markdown 特来了很纯粹的文档内容，并且可以优于 word 等方案的版本管理优点，文档的任何变动，可以以 diff 的方式像代码一样的查看到文档的修改细节；从可读性方面，markdown 完全可以加入自己所需要的样式编译输出为纯静态的 html 文档，再配合一些目前开源的工具，完全可以实现更多的功能。 1 学生管理（接口包） 1.1 接口标题（格式示例） 描述： 接口相关说明 请求URL： http://xx.xx.com:80/xxx/ 请求方式： GET 参数： 参数名 必选 类型 说明 xxxx 是 string 参数说明 返回示例： 1234&#123; xxx: xx ...&#125; 返回参数说明： 参数名 类型 说明 status int 1：为成功；0：为失败 备注： 其他相关内容说明 1.2 单个学生登录（DEMO） 描述： 学生登录接口，账号由教师一键生成，默认密码 123456。 请求URL： https://xxx.xxx.com:8080/student/login 请求方式： POST 参数： 参数名 必选 类型 说明 idcard 是 string 身份证号码 password 是 string 密码 返回示例： 123&#123; 'res': 1&#125; 返回参数说明： 参数名 类型 说明 res int 1 为成功 0为失败 备注： 此接口同时会返回 Cookie]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo基础搭建博客系统]]></title>
    <url>%2F2017%2F10%2F13%2Fhexo-base-deploy%2F</url>
    <content type="text"><![CDATA[1 介绍&amp;安装 1.1 简单的过程 1.2 安装主题 1.3 默认配置导入 2 博客文章新建 3 部署&amp;发布 3.1 生成 3.2 部署 3.3 一步到位 为了更好的使用 hexo 博客系统，对相关的配置进行一个基本的梳理或是内置默认值，其中使用 next 作为其中默认的主题样式，以此来美化 hexo 本身自带的一套主题。系统提供有独立的 github 仓库，同时通过对相关细节记录下来，以达到后期回看，或是另外环境快速搭建的目的。 1 介绍&amp;安装 本系统是基于 hexo 搭建，因此，我们需要先安装好 hexo 的基础环境。 hexo 帮助说明 在 hexo 的官网，有详细的说明，如何搭建 hexo 的命令环境，以及基础 node 环境的安装也都有详细说明。 1.1 简单的过程 1234## 安装 hexonpm install -g hexo-cli## 初始化 hexo，其中 blog 为你希望用于存储博客文件的目录名称，可以自行决定hexo init blog 1.2 安装主题 因本次的系统，我们默认以 next 为博客的默认主题，因此我们可以通过 github 来实现 next 的安装。 123git clone https://github.com/iissnan/hexo-theme-next themes/next# 或使用SVNsvn export https://github.com/iissnan/hexo-theme-next.git/trunk/ themes/next --force 以上的两种情况，你可以根据你个人的喜好和环境选择一种方式即可。 1.3 默认配置导入 在本次的搭建过程中，hexo 本身存在有很多的相关配置，因此，经过梳理，将相关配置开了一个项目，托管到了 github，我们可以通过将这份线上的配置下载到本地博客系统中，即可实现一次性配置。 123svn export https://github.com/lfire/wumiblog.git/trunk/ ./ --force## 安装依赖npm install 2 博客文章新建 环境搭建完成后，我们就可以开始文章的写作了。写作过程中，hexo 设计了一个【layout】的概念，从字面来理解，就是布局的意思，也可以理解为模板，如果有相关能力者，你也可以开发相应的 layout 来支持更为丰富的功能，这点上，不再展开，具体可以查看官方的相关文档。 以下记录几种常用的 layout 页的建立命令： 1234## 创建标签页hexo new page "tags"## 创建分类页hexo new page "categories" 需要注意的是，在实际使用过程中，我们新建普通的博客文章，这个 layout 参数是可以省略的，如： 1hexo new hello-hexo 执行之后，就会在对应的目录下（如目录名为 blog，则路径为：blog/source/_posts/hello-hexo.md）生成相关文件。 3 部署&amp;发布 在配置文件中（blog/_config.yml），如下图，会有 github 部署位置的一个配置，本例中，使用的只是一个演示 demo，有需要的可以自已修改为对应的位置即可。 配置部署位置后，我们就可以执行相关命令来完成部署。 3.1 生成 1234## 先将 markdown 文档转化为静态 HTML 文件资源hexo generate## or 缩写hexo g 3.2 部署 1234## 将生成的静态文件上传部署到配置位置hexo deploy## or 缩写hexo d 3.3 一步到位 123456hexo generate --deploy## orhexo deploy --generate## or 缩写hexo g -dhexo d -g]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10 升级后 cmder 别名失效修复]]></title>
    <url>%2F2017%2F03%2F10%2Fcmder-chinese-win10%2F</url>
    <content type="text"><![CDATA[1 问题表现，别名全部失效 2 查找答案 近期系统接收到了 win10 的慢速升级推送，但发现，升级过后，系统原先配置好的 cmder 别名全都无法正常工作。在 cmder github 上也试图查找相关的解决方案，但很多的说法以及配置都没能解决，最后，在一个地方发现了问题的初步解决方案。 1 问题表现，别名全部失效 表现是相关加载都能成功，但命令本身就是不生效，无法工作，并且，相关中文也会产生叠加现象。 2 查找答案 我通过 google 查找各种可能性，最后终于在 github cmder issues 查找到了需要的答案。 原来， Ok guys, found what the issue was. I am using Windows 10 Insider build 15025 - the problem was with modification that were made by Microsoft to standard cmd.exe To solve this I had to “Use legacy console” option in standard cmd - which solved this issue. 是因 win10 升级，可能其内部改变了某些终端的特性，我们需要禁用新的控制台。 这样配置完成后，我们重新打开 cmder 一次，** OK，问题解决 **。]]></content>
      <categories>
        <category>工具</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>cmder</tag>
        <tag>shell tool</tag>
        <tag>cmder alias</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder & cygwin 中文支持解决方案]]></title>
    <url>%2F2017%2F03%2F08%2Fcmder-cygwin-chinese%2F</url>
    <content type="text"><![CDATA[1 使用环境 &amp; 场景 2 cmder 方案 2.1 界面配置 2.2 终端环境变量 2.3 相关工具的配置 3 cygwin 方案 3.1 界面配置 3.2 环境变量配置 3.3 相关工具配置 4 综合方案 在 windows 环境下，我们因系统本身自带的 cmd 方案表现很弱，所以我们经常使用其他的解决方案来弥补。而这些方案中最为常见和好用的也就是 cmder 和 cygwin 两种。 今天对于方案中，我们常遇到的问题——中文编码乱码问题来配置使用。 1 使用环境 &amp; 场景 中文环境下，最为常见的编码就是： GBK UTF-8 而在 windows 环境下，这两种编码的文件同时存在是非常常见的，而在 cmd 的终端环境下，想要一次性解决该显示问题，目前来说并不容易，因此，我们当前只能寻找一种最为全面的解决方案，以最大可能来解决该问题。 因此，目前需要来分析一下使用的场景： 程序员编码 各工具使用，如： git、svn等 而对于编码的场景下，我们目前最为推荐的编码格式仍是 utf-8 ，所以，这里也一样的不解释，建议使用 utf-8。 而对于 git &amp; svn 等相关的版本管理工具，这里也是程序员常有遇到的场景，而在 git 序列中，github 的使用常在手边过，而 github 所支持的中文编码就是 utf-8 。 从这些相关的场景分析来看，我们所有可控的场景中，我们最好使用的编码仍然是 utf-8 。 因此，这里本人也强烈推荐各位，在可以自己控制的情况下，我们应该首选 utf8。 场景的主编码确定好后，我们就可以分别针对两种不同工具，来进行相关的支持配置。 配置总体可以分为： 软件界面 终端环境变量 相关工具配置 2 cmder 方案 2.1 界面配置 右键标题栏 &gt; settings Main &gt; Font charset 这里选择 GB 2312 主要是因为，windows 系统的主要编码还是：ANSI。 2.2 终端环境变量 Settings &gt; Startup &gt; Environment 这里的设置，需要关闭 cmder 再重新打开一次生效。 我们可以通过 locale 命令查看设置的结果： 123456789λ localeLANG=zh_CN.utf-8LC_CTYPE="zh_CN.utf-8"LC_NUMERIC="zh_CN.utf-8"LC_TIME="zh_CN.utf-8"LC_COLLATE="zh_CN.utf-8"LC_MONETARY="zh_CN.utf-8"LC_MESSAGES="zh_CN.utf-8"LC_ALL= 在新版本 V 1.3.5 中发现无法通过界面设置环境变量保存成功，下面提供另一种实现方法： 在安装目录下找到用户配置文件路径 config/user-profile.cmd ，打开编辑，在其中加入环境变量配置语句： 1set LANG=zh_CN.utf-8 2.3 相关工具的配置 git 配置 在 git 命令行下，主要是与： i18n.commitencoding i18n.logoutputencoding 两个配置参数有关，我们可以通过以下命令进行配置： 12λ git config --global i18n.commitencoding utf-8λ git config --global i18n.logoutputencoding utf-8 VIM 配置 vim 是终端下最为常见的文档编辑器，我们可以在 VIM 的配置文件中加入如下配置： 12set fileencoding=cp936set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1 注： 查找 vim 配置文件的位置，可以通过进入 vim 后，输入 :version 3 cygwin 方案 3.1 界面配置 右键标题栏 &gt; Options Text 3.2 环境变量配置 修改 ~/.bashrc 文件，加入： export LANG=“zh_CN.UTF-8” export OUTPUT_CHARSET=“UTF8” 3.3 相关工具配置 git 和 vim 的配置与 cmder 下是一致的，可以采用同样的方式来处理。 4 综合方案 cmder 是一种终端集成器，它同样可以将 cygwin 集成到其内部窗口上。 具体的配置方式，我们可以参考 cmder 官方手册 以下是本人的配置截图： 配置后的运行效果图：]]></content>
      <categories>
        <category>工具</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>cmder</tag>
        <tag>cygwin</tag>
        <tag>shell中文支持</tag>
        <tag>windows shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神器 cmder]]></title>
    <url>%2F2017%2F03%2F02%2Fcmder%2F</url>
    <content type="text"><![CDATA[1 windows cmd 不足 2 神器登场 cmder 3 主要特性 3.1 提供高度类 Linux 的终端体验 3.2 快捷键支持丰富 3.3 支持命令别名(Aliases)配置 3.4 对于中文支持的处理 4 整体配置及软件包下载 当我们在 windows 环境下来进行开发编码工作时，是不是经常有一个不好的体验—— cmd 太弱了。 1 windows cmd 不足 界面太过于死板，不美观 相关的操作，以及命令支持不完善，无法达到，或是平衡 linx 平台下相关的操作习惯 当前各种框架平台不断发展，相关需要在命令行下执行的操作越来越多，而cmd没有多标签等相关的切换功能 窗口的大小直接受限，不能自如的调整窗口大小 … 以上所列出的点不尽全，相信只要有需要使用 shell 来进行终端操作的用户就能感觉到 windows 对于用户，在这方面的不友好。而现实的开发工作序列中，无论是我们的代码管理，还是我们的环境编译，以及其他相关框架或平台的应用，如若想完全的脱离终端，这种可能性及小。 另外，从操作的效率性方面来出发，命令行下的操作，要比鼠标和键盘的来回切换操作来得高效和方便。（也许你不太认可，但这是很大一部分人公认的。） 2 神器登场 cmder cmder 是一款绿色且开源的软件，并且已经托管在了 github 上，其主要的目标即是在 windows 平台上，打造类 linux 的终端操作体验。 先来一张靓照： 从图中我们可以看到，中文支持友好，同时，终端的颜值很高，最最主要的是，本软件是高度可定制的。 只要是你愿意，你完全可以根据你自己的喜好，自定出一套你自己喜欢的主题出来。 如下图所示，你可以打开 Settings 来配置你自己的各种需要 3 主要特性 3.1 提供高度类 Linux 的终端体验 在我们平常的使用命令终端的体验过程中，如若能达到 linux 平台下相关命令的可靠性，那即是 windows 平台下开发者的福音，而 cmder 正是朝着这一方向而来的。可以支持的初略的列一下： pwd ll ls whoami where cp rm unzip … 3.2 快捷键支持丰富 打开设置： 使用 win + alt + p 新建标签： ctrl + t 关闭标签： ctrl + w 快速新建不同类型标签： shift + alt + number cmd PowerShell 全屏： alt + enter 返回上级目录： ctrl + alt + u 历史查询： ctrl + r 选择复制文本： left mouse select 粘贴文本： right click 更多的快捷键，你可以打开 Settings &gt; Keys &amp; Macro 中进行设置和查看。 3.3 支持命令别名(Aliases)配置 这是 cmder 所提供的一个非常方便的功能，我们可以很个性化的设置我们个人喜欢的命令，来完成某些长命令的输入。 以下是我别名配置的一个片段，大家可参考： &#123;.line-numbers&#125;123456789101112pwd=cdclear=clshistory=cat "%CMDER_ROOT%\config\.history"unalias=alias /d $1vi=vim $*cmderr=cd /d "%CMDER_ROOT%"e.=explorer .gl=git log --oneline --all --graph --decorate $*l=ls --show-control-chars --color $*la=ls -aF --show-control-chars --color $*ll=ls -alF --show-control-chars --color $*ls=ls --show-control-chars -F --color $* 3.4 对于中文支持的处理 在平常应用过程中，我们经常会遇到中文问题的苦恼，如何很好的解决中文在各种场景下的显示问题，是很多类似产品的一大痛点。 常见场景： 中文文件或中文文件夹名的显示和操作； VIM 中打开包含中文内容的文件查看及编辑等； git 提交代码到 github 等代码仓库时，中文日志的提交及查看； 几个关键配置要点： 中文字体的选择：我们需要选择相关支持中文字符显示的字体来做为软件的展示字体。 字符编码的选择：在 windows 下，很多文件名，及文件的编码都是以 GBK 为编码，因此，这里我们需要很慎重的选择软件的字体编码。 环境变量的设置：因本软件的类 linux 的设计，所以很多命令，如 git 都有着 linux 下相似的处理逻辑，而 github 这种是全以 UTF8 为编码的平台，因此，环境变量需要对此进行特殊处理。 VIM 的字符编码配置：因是在 windows 平台中，很多的文件的编码可能是多种多样的，不是固定的某一种，因此，在 VIM 的配置中，就必须要考虑到这种情况，配置让它可以智能的识别并转换文件内容编码。 以下贴出我所配置的部分参数： 字体&amp;字体编码配置 其中的 YaHei Consolas Hybrid 是我在编程过程中，所遇到的一种字体，对于中文、英文大小写、以及数字的支持以及辨识度很高。个人推荐使用，可以这下载安装，提取密码: tmgw 而其中因是在 windows 环境下，所以建议使用 GB2312 编码。 环境变量配置 为兼容 github 等使用，整体将 cmder 的环境变量中 LANG 设置为 UTF-8 ，以此实现 git log 等命令查看时支持中文。 VIM配置 为实现 VIM 支持各种编码格式文件的中文查看及编辑，cmder 内部已做好了配置进行处理，上图只是将相关的配置内容贴出。 4 整体配置及软件包下载 为方便大家直接使用，我将当前我所使用的版本，以及配置整体打包分享出来。 推荐大家使用，提取密码: 1aix]]></content>
      <categories>
        <category>工具</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>cmder</tag>
        <tag>shell</tag>
        <tag>tool</tag>
        <tag>工具</tag>
        <tag>windows cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Quick Start Create a new post Run server Generate static files Deploy to remote sites Test the application 制作一份待办事宜 Todo 列表 书写一个质能守恒公式[^LaTeX] 高亮一段代码[^code] 高效绘制 流程图 绘制表格 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy Test the application 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 书写一个质能守恒公式[1] E=mc2E=mc^2 E=mc2 高亮一段代码[2] 1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 高效绘制 流程图 12345678910111213141516st=&gt;start: Start:&gt;https://www.baidu.com&apos;editor&apos;: &apos;&apos;io=&gt;inputoutput: verification&apos;editor&apos;: &apos;&apos;op=&gt;operation: Your Operation&apos;editor&apos;: &apos;&apos;cond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io Another 12345678910digraph G &#123; 开始 -&gt; A A -&gt; B B -&gt; D B -&gt; C A -&gt; C C -&gt; E D -&gt; E E -&gt; 结束&#125; 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 More info: Deployment 支持 LaTeX 编辑显示支持，例如：∑i=1nai=0\sum_{i=1}^n a_i=0∑i=1n​ai​=0， 访问 MathJax 参考更多使用方法。 ↩︎ 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 ↩︎]]></content>
      <categories>
        <category>init</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
